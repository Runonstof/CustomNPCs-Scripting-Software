//==Reallife date handler for hiring regions etc
var msTable = {
	'y': 31556926000,
	'mon': 2629743830,
	'w': 604800000,
	'd': 86400000,
	'h': 3600000,
	'min': 60000,
	's': 1000,
	'ms': 1
};

Date.prototype.addTime = function(addTime) {
	this.setTime(this.getTime()+addTime);
};

Date.prototype.hasPassed = function(passDate) {
	return (this.getTime() >= passDate.getTime());
}

//Converts TimeString to number
function getStringTime(timeString) {
	//0y4mon3d 6h 8min3s 800ms
	var reg = /([\d]+)([a-zA-Z]+)/g;
	var _m = timeString.match(reg);
	var newTime = 0;
	var _tk = Object.keys(msTable);
	
	for(m in _m) {
		var fm = _m[m];
		var nm = fm.replace(reg, '$1').cInt();
		var om = fm.replace(reg, '$2');
		if(nm != null) {
			if(_tk.indexOf(om) != -1) {
				newTime += nm * (msTable[_tk[_tk.indexOf(om)]]);
			} else { newTime += nm; }
		}
	}
	
	return newTime;
}
//Converts number to TimeString
function getTimeString(stringTime, excludes) {
	if(typeof(excludes) == typeof(undefined)) { var excludes = []; }
	var newTime = parseInt(stringTime);
	var newStr = '';
	for(ms in msTable) {
		if(excludes.indexOf(ms) == -1) {
			var msnum = 0;
			while(newTime >= msTable[ms]) {
				msnum++;
				newTime -= msTable[ms];
			}
			if(msnum > 0) {
				newStr += msnum.toString()+ms;
			}
		}
	}
	
	
	return newStr;
}String.prototype.allMatch = function(regx) {
	var m = this.match(regx);
	var rr = [];
	for(mm in m) {
		var mt = m[mm];
		var rx = regx.exec(this);
		rr.push(rx);
	}
	
	return rr;
};

String.prototype.rangeUpper = function(min, max) {
	var str = '';
	for(var i = 0; i < this.length; i++) {
		var c = this.substring(i, i+1); //curchar
		if(i >= min && i < max) {
			c=c.toUpperCase();
		}
		str+=c.toString();
	}
	return str;
}

String.prototype.pad = function(character, len) {
	var n = this.toString();
	for(i = n.length; i < len; i++) {
		n += character.toString();
	}
	return n;
}

String.prototype.padMiddle = function(character, len) {
	
	var n = this.toString();
	var sc = Math.floor((len-n.length)/2);
	var ns = '';
	for(i = 0; i < sc; i++) {
		ns += character.toString();
	}
	ns+=n;
	for(i = 0; i < sc; i++) {
		ns += character.toString();
	}
	return ns;
}

String.prototype.cInt = function() {
	return (isNaN(parseInt(this)) ? null : parseInt(this));
}

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};


var ASSET_MOD_ID = "adventureassets";
var Items = { 
	Tools: {
		Pickaxes: [
			"minecraft:wooden_pickaxe",
			"minecraft:stone_pickaxe",
			"minecraft:iron_pickaxe",
			"minecraft:golden_pickaxe",
			"minecraft:diamond_pickaxe",
			"dungeontactics:gilded_pickaxe",
			"dungeontactics:jewelled_pickaxe",
			"extragems:ruby_pickaxe",
			"extragems:sapphire_pickaxe",
			"extragems:topaz_pickaxe",
			"extragems:amethyst_pickaxe",
			"extragems:crystal_pickaxe",
			"aether_legacy:skyroot_pickaxe",
			"aether_legacy:holystone_pickaxe",
			"aether_legacy:zanite_pickaxe",
			"aether_legacy:gravitite_pickaxe",
			"aether_legacy:valkyrie_pickaxe",
		],
		Axes: [
			"minecraft:wooden_axe",
			"minecraft:stone_axe",
			"minecraft:iron_axe",
			"minecraft:golden_axe",
			"minecraft:diamond_axe",
			"aether_legacy:skyroot_axe",
			"aether_legacy:holystone_axe",
			"aether_legacy:zanite_axe",
			"aether_legacy:gravitite_axe",
			"aether_legacy:valkyrie_axe",
			"extragems:ruby_axe",
			"extragems:sapphire_axe",
			"extragems:amethyst_axe",
			"extragems:topaz_axe",
			"extragems:crystal_axe",
			"extragems:emerald_axe",
		]
	},
	Combat: {
		Shields: [
			"dungeontactics:wooden_shield",
			"dungeontactics:stone_shield",
			"minecraft:shield",
			"dungeontactics:tin_shield",
			"dungeontactics:copper_shield",
			"dungeontactics:bronze_shield",
			"dungeontactics:iron_shield",
			"dungeontactics:gold_shield",
			"dungeontactics:diamond_shield",
			"dungeontactics:emerald_shield",
			"dungeontactics:amethyst_shield",
			"dungeontactics:sapphire_shield",
			"dungeontactics:ruby_shield",
			"dungeontactics:topaz_shield",
			"dungeontactics:crystal_shield",
			"dungeontactics:gilded_shield",
			"dungeontactics:jewelled_shield",
		]
	}
}

function getHalfRotation(angle) {
	angle = fixAngle(angle);
	if(angle <= 180) { return angle; } else { return -(180-(angle-180)); }
}

function getQuartRotation(dir) {
	dir = getHalfRotation(dir);
	
	if(Math.abs(dir) > 90) {
		dir = (180-Math.abs(dir))*sign(dir);
	}
	
	return dir;
}

function playerIsOnline(world, player) {
	var isOnline = false;
	var pl = world.getAllPlayers();
	for(p in pl) {
		if(pl[p].getName() == player.toString()) {
			isOnline = true;
			break;
		}
	}
	return isOnline;
}

function getHandItem(player) {
	return player.getMainhandItem() || player.getOffhandItem();
}
function uniqid() {
	var id = '';
	for(var i = 0; i <= 3; i++) {
		id+=Math.random().toString(36).substr(2, 9);
	}
	return id;
}

function occurrences(string, subString, allowOverlapping) {
	if(typeof(allowOverlapping) == typeof(undefined)) { var allowOverlapping = false; }
    string += "";
    subString += "";
	
    if (subString.length <= 0) return (string.length + 1);

    var n = 0,
        pos = 0,
        step = allowOverlapping ? 1 : subString.length;

    while (true) {
        pos = string.indexOf(subString, pos);
        if (pos >= 0) {
            ++n;
            pos += step;
        } else break;
    }
    return n;
}

function arrayTakeRange(arr, start, end) {
	if(typeof(end) == typeof(undefined)) { var end = null; }
	if(end == null) { end = arr.length; }
	var a = [];
	var _end = Math.min(end, arr.length);
	var _start = Math.min(start, _end);
	for(var i = _start; i < Math.min(end, arr.length); i++) {
		if(typeof(arr[i]) != typeof(undefined)) {
			a.push(arr[i]);
		}
	}
	return a;
}


function sign(num) {
	if(typeof(num) == typeof(undefined)) { var num = 0; }
	if(num > 0) { return 1; }
	if(num < 0) { return -1; }
	return 0;
}


var javaObject = Java.type("java.lang.Object");
Java.extend(javaObject, {
	tryIndex: function(index) {
		for(i in index) {
			var ii = index[i].toString();
			if(this[ii] != null) { return this[ii]; }
		}
		return -1;
	}
})

function g(obj, grp_props) {
	for(j in grp_props) {
		var props = grp_props[j];
		for(i in props[0]) {
			if(obj != null) {
				if(typeof(obj[props[0][i]]) != typeof(undefined)) {
					obj = obj[props[0][i]];
					
					break;
				}
			}
		}
	}
	
	
	return obj;
}

function getAllFuncs(obj) {
    var props = [];

    do {
        props = props.concat(Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props.sort().filter(function(e, i, arr) { 
       if (e!=arr[i+1] && typeof obj[e] == 'function') return true;
    });
}

function removeFromArray(arr, vals) {
	if(typeof(vals) == 'string') { vals = [vals]; }
	var a = [];
	arr.forEach(function(el){a.push(el);});//Copy array
	for(v in vals) {
		var i = arr.indexOf(vals[v]);
		if(i > -1) {
			a.splice(i, 1);
		}
	}
	
	return a;
}

var _RAWCOLORS = {
	'0': 'black',
	'1': 'dark_blue',
	'2': 'dark_green',
	'3': 'dark_aqua',
	'4': 'dark_red',
	'5': 'dark_purple',
	'6': 'gold',
	'7': 'gray',
	'8': 'dark_gray',
	'9': 'blue',
	'a': 'green',
	'b': 'aqua',
	'c': 'red',
	'd': 'light_purple',
	'e': 'yellow',
	'f': 'white',
};

function strf(str, toRaw) {
	if(typeof(toRaw) == typeof(undefined)) { var toRaw = false; }
	return strrawformat(str, toRaw);
}

function strrawformat(str, toRaw) {
	if(typeof(toRaw) == typeof(undefined)) { var toRaw = false; }
	var rf = [];
	var txt = '';
	var ri = -1;
	var isCode = false;
	var txtColor = 'white';
	var isItalic = 0;
	var isBold = 0;
	var isStrike = 0;
	var isUnderlined = 0;
	var isObf = 0;
	str = str+'&r ';
	
	for(var i = 0; i < str.length; i++) {
		var c = str.substr(i, 1);
		if(c == '&' || i == str.length-1) {
			//Check if new section has to be made
			if(txt.length > 0) {
				ri++;
				var cmds = [];
				
				rf.push([txt, txtColor, isItalic, isBold, isUnderlined, isStrike, isObf]);
				isItalic = false;
				isBold = false;
				isUnderlined = false;
				isStrike = false;
				isObf = false;
				txtColor = 'white';
				txt = '';
			}
			isCode = true;
			continue;
		} else {
			if(!isCode) {
				txt += c.toString();
			} else {
				//Check Colors
				if(typeof(_RAWCOLORS[c]) != typeof(undefined)) {
					txtColor = _RAWCOLORS[c];
				}
				//Check Markup
				switch(c.toString()) {
					case 'o': {
						isItalic = true;
						break;
					}
					case 'l': {
						isBold = true;
						break;
					}
					case 'n': {
						isUnderlined = true;
						break;
					}
					case 'm': {
						isStrike = true;
						break;
					}
					case 'k': {
						isObf = true;
						break;
					}
					case 'r': {
						isItalic = false;
						isBold = false;
						isUnderlined = false;
						isStrike = false;
						isObf = false;
						txtColor = 'white';
						break;
					}
				}
				isCode = false;
			}
		}
	}
	
	return (!toRaw ? rf : rawformat(rf));
}


function rawformat(str_pieces, fullraw) {
	if(typeof(fullraw) == typeof(undefined)) { var fullraw = true; }
	//print("FULLRAR: "+fullraw.toString());
	var txt = '';
	if(fullraw) { txt+='[""'; }
	
	for(i in str_pieces) {
		var p = str_pieces[i];
		p[0] = p[0].replace(/\"/g, '\\"');
		var pc = '{"text":"'+p[0].toString()+'"';
		if(p[1]) { pc+=',"color":"'+p[1].toString()+'"'; }
		if(p[2]) { pc+=',"italic":true'; }
		if(p[3]) { pc+=',"bold":true'; }
		if(p[4]) { pc+=',"underlined":true'; }
		if(p[5]) { pc+=',"strikethrough":true'; }
		if(p[6]) { pc+=',"obfuscated":true'; }
		if(p[7]) { pc+=',"clickEvent":{"action":"run_command","value":"'+p[6]+'"}'; }
		pc += '}';
		
		txt+=','+pc.toString();
	}
	
	if(fullraw) {
		txt += ']';
	}
	return txt;
	

}

function data_get(data, keys) {
	var get = {};
	for(k in keys) {
		//var key = keys[k];
		get[k] = data.get(k);
		if(get[k] == null) { get[k] = keys[k]; }
	}
	
	return get;
}

function data_register(data, vals) {
	for(k in vals) {
		var val = vals[k];
		if(data.get(k) == null) { data.put(k, val); }
	}
}

function clone(obj) {
    var copy;

    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}

function data_overwrite(data, keys, vals) {
	if(typeof(keys) == typeof(undefined)) { var keys = []; }
	if(typeof(vals) == typeof(undefined)) { var vals = []; }
	if(typeof(keys) == 'string') { keys = [keys]; }
	if(typeof(vals) == 'string') { vals = [vals]; }
	
	for(k in keys) {
		var key = keys[k];
		var val = vals[k];
		data.put(key, val);
	}
}

function posdir(pos, dir, pitch, len, flying) {
	if(typeof(dir) == typeof(undefined)) { var dir = 0; }
	if(typeof(pitch) == typeof(undefined)) { var pitch = 0; }
	if(typeof(len) == typeof(undefined)) { var len = 1; }
	if(typeof(flying) == typeof(undefined)) { var flying = false; }
	var x = pos.getX();
	var y = pos.getY();
	var z = pos.getZ();
	var xdir = getQuartRotation(dir);
	var zdir = getQuartRotation(dir-90);
	x += Math.round(len*(Math.abs(xdir)/90)*sign(xdir));
	z += Math.round(len*(Math.abs(zdir)/90)*sign(zdir));
	if(flying) {
		y += (len)*(Math.abs(pitch)/90)*-sign(pitch);
	}
	return {x:x,y:y,z:z};
}


function fixAngle(angle) {
	angle = Math.abs(angle);
	if(angle >= 360) { angle -= 360; }
	return angle;
}

function lengthpitch_y(pitch, length) {
	return Math.round(pitch/-90)*length;
}


function lengthdir_x(angle, length) {
	if(typeof(length) == typeof(undefined)) { var length = 1; }
	return Math.round((getQuartRotation(angle)/90)*length);
}

function lengthdir_z(angle, length) {
	if(typeof(length) == typeof(undefined)) { var length = 1; }
	angle = fixAngle(angle+270);
	return -lengthdir_x(angle, length);
}

function pick(a, amount) {
	if(typeof(amount) == typeof(undefined)) { var amount = 1; }
	var index = Math.floor(Math.random() * a.length);
	amount = Math.min(a.length, amount);
	if(amount == 1) {
		return a[index];
	} else {
		var picks = [];
		
		while(picks.length < amount) {
			index = Math.floor(Math.random() * a.length);
			if(picks.indexOf(a[index]) == -1) { picks.push(a[index]); }
		}
		
		return picks;
	}
}

function escapeNbtJson(json, trim_ends) {
	if(typeof(trim_ends) == typeof(undefined)) { var trim_ends = true; }
	json = json.replace(/(?:\\n|\\)/g, '');
	json = json.replace(/(\d) ([fbds]+)/g, "$1$2");
	json = json.replace(/\\("|')/g, "$1");
	if(trim_ends) {
		json = json.slice(1, json.length - 1);
	}
	
	return json;
}


function array_remove(array, element) {
  var index = array.indexOf(element);

  if (index !== -1) {
    array.splice(index, 1);
  }
}

function pickwhere(a, fn, amount) {
	return pick(array_filter(a, fn), amount);
}

function array_dist(a) {
	var b = [];
	for(c in a) {
		if(b.indexOf(a[c]) == -1) {
			b.push(a[c]);
		}
	}
	
	return b;
}

function array_filter(a, fn) {
	var aa = [];
	for(i in a) {
		if(fn(a[i])) { aa.push(a[i]); }
	}
	
	return aa;
}

function ccs(str) { return colorCodeString(str); }

function colorCodeString(str) {
	return str.replace(/&/g, '\u00A7');
}

function genName(name) {
	var p = [
    'Amazing',
    'Awesome',
    'Blithesome',
    'Excellent',
    'Fabulous',
    'Fantastic',
    'Favorable',
    'Gorgeous',
    'Incredible',
    'Outstanding',
    'Perfect',
    'Propitious',
    'Remarkable',
    'Rousing',
    'Spectacular',
    'Splendid',
    'Stellar',
    'Super',
    'Upbeat',
    'Unbelievable',
    'Wondrous',
	'Tempered',
	'Legendary',
	'Magical'
	];
	var s = [
		'Destruction',
		'Slaughter',
		'Starlight',
		'Heroism',
		'Bonebreaking',
		'The Fallen',
		'Silence',
		'Spellkeeping',
		'Massacre',
		'Sanity',
		'Insanity',
		'Remorse',
		'Fury'
	];
	
	return pick(p) + ' ' + name + ' of ' + pick(s);
}

function nbtCopy(nbt, api) {
	return api.stringToNbt(nbt.toJsonString());
}

function getDayTime(time) {
	while(time > 24000) { time -= 24000; }
	return time;
}

function random_ranges(min, max, amount) {
	var a = 0;
	for(var i = 0; i < amount; i++) { a += random_range(min, max); }
	return a;
}

function rrandom_ranges(min, max, amount) {
	var a = 0;
	for(var i = 0; i < amount; i++) { a += rrandom_range(min, max); }
	return a;
}

function pickchance(a, amount) {
	var aa = [];
	for(e in a) {
		if(!isArray(a[e])) {
			aa[aa.length] = a[e];
		} else {
			for(var i = 0; i < a[e][1]; i++) {
				aa[aa.length] = a[e][0];
			}
		}
	}
	
	return pick(aa, amount);
}

function inArray(a, val) {
	for(k in a) { if(a[k] === val) { return true; } }
	return false
}

function rrandom_range(min, max) { return Math.round(random_range(min, max)); }

function random_range(_min, _max) {
	var min = Math.min(_min, _max);
	var max = Math.max(_min, _max);
	
	var diff = max - min;
	
	return (min + (Math.random() * diff));
}

function array_merge(a1, a2) {
	var bb = [];
	for(k in a1) {
		bb[k] = a1[k];
	}
	for(k in a2) {
		bb[k] = a2[k];
	}
	return bb;
}

function isArray(obj) {
	if(typeof(obj) === 'object') {
      for(k in obj) {
      
          if(isNaN(k)) { return false; }
      }
      

      return true;
    } else { return false }
}

function isObject(obj) {
	return ( typeof(obj) === 'object' && !isArray(obj) );
}


function nbtItem(nbt, w, api) {
	if(typeof(nbt) == 'string') { nbt = api.stringToNbt(nbt); }
	var item = w.createItemFromNbt(nbt);
	
	return item;
}
function executeCommand(player, command, as_player) {
	if(typeof(as_player) == typeof(undefined)) { var as_player = true; }
	var API = Java.type('noppes.npcs.api.NpcAPI').Instance();
	var cmd = API.createNPC(player.world.getMCWorld());
	if(as_player) {
		return cmd.executeCommand("/execute "+player.getName()+" ~ ~ ~ "+command);
	} else {
		return cmd.executeCommand("/noppes script reload");
	}
}
function tellPlayer(player, rawtext) {
	if(typeof(rawtext) == 'string') { var rawtext = strf(rawtext); }
	
	return executeCommand(player, "/tellraw "+player.getName()+" "+rawformat(rawtext));
}

function tellPlayerStr(player, text) {
	return executeCommand(player, "/tellraw "+player.getName()+" "+text.toString());
}

function storytellPlayer(player, ar) {
	for(i in ar) {
		//print(ai[i].join('==='));
		tellPlayer(player, ar[i]);
	}
}

/*
function storyte_llPlayer(player, array_rawtext) {
	var tellStr = '[""';
	for(i in array_rawtext) {
		if(tellStr.substr(tellStr.length-1, tellStr.length) != ',' && tellStr.length > 0) {
			tellStr += ',';
		}
		tellStr += rawformat(array_rawtext[i], false).toString();
		if(i < array_rawtext.length-1) {
			tellStr += ',{"text":"\n"}';
		}
	}
	tellStr += ']';
	print(tellStr);
	return tellPlayerStr(player, tellStr);
}*/
var _COMMANDS = {
	'test': function(player, args) {
		executeCommand(player, "/title "+player.getName()+' actionbar '+strf("&9&lHello\nThere!", true));
	},
	'getdimensioninfo': function(player, args) {
		if(hasPermission(player, 'getdimensioninfo')) {
			var dim = player.world.getDimension();
			tellPlayer(player, strf("&aDimension ID: &c"+dim.getId().toString()));
			tellPlayer(player, strf("&aDimension Name: &c"+dim.getName().toString()));
			tellPlayer(player, strf("&aDimension Suffix: &c"+dim.getSuffix().toString()));
		}
	},
	'mail': function(player, args) {
		if(hasPermission(player,  "mail")) {
			if(args.length >= 1) {
				var mcmd = args[0];
				switch(mcmd) {
					case 'send': {
						if(hasPermission(player, "mail.send")) {
							if(args.length >= 4) {
								var toPl = args[1];
								var toTitle = args[2];
								var toMsg = arrayTakeRange(args, 3, args.length).join(' ');
								var data = player.world.getStoreddata();
								sendMail(data, player.getName(), toPl, toTitle, toMsg);
								if(playerIsOnline(player.world, toPl)) {
									executeCommand(player, "/tellraw "+toPl+" "+strf("&7You have new mail!", true));
								}
								tellPlayer(player, "&aSuccessfully sent mail to "+toPl);
							} else {
								tellPlayer(player, "&c!mail send <player_name> <title> <message>");
							}
						}
						break;
					}
					case 'read': {
						if(hasPermission(player, "mail.read")) {
							var data = player.world.getStoreddata();
							var mails = getMail(data, player);
							var matches = [];
							if(args.length >= 2) { matches = arrayTakeRange(args, 1, args.length); }
							var showed = 0;
							if(mails.length > 0) {
								var t = 0;
								for(m in mails) {
									var isMatch = matches.length == 0;
									if(!isMatch) {
										//Check title
										for(mm in matches) {
											if(occurrences(mails[m].title, matches[mm]) > 0) {
												isMatch = true;
											}
										}
									}
									if(isMatch) {
										tellPlayer(player, "&l[=======] &aAlteria Mail &l[=======]")
										var ago = getTimeString((new Date().getTime() - mails[m].time), ['ms']);
										var from = mails[m].from;
										tellPlayer(player, "&7From: &r&o"+(from!=null?from:'&c&lAlteria'));
										tellPlayer(player, "&7Sent "+ago+" ago");
										tellPlayer(player, "&7Title: &r&o"+mails[m].title);
										tellPlayer(player, "&7Message: &r&o"+mails[m].msg);
										if(t < mails.length-1) {
											tellPlayer(player, "&l[=====================]");
										}
										showed++;
									}
									t++;
								}
								
								if(showed == 0) {
									tellPlayer(player, "&cNo mails found"+(matches.length == 0 ? '.' : ' with given matches.'));
								}
							} else {
								tellPlayer(player, "&7You don't have any mail!");
							}
						}
						break;
					}
					case 'delete': {
						if(hasPermission(player, "mail.delete")) {
							var data = player.world.getStoreddata();
							var mailcount = getMail(data, player).length;
							deleteMail(data, player.getName());
							tellPlayer(player, "&7Deleted "+mailcount+" mail(s).");
						}
						break;
					}
					default: {
						tellPlayer(player, "&cUnknown mail command");
						break;
					}
				}
			} else {
				tellPlayer(player, strf("&eProper Usage: &c!mail <send|read|delete>"));
			}
		}
	},
	'jointeam': function(player, args) {
		if(hasPermission(player, 'jointeam')) {
			if(args.length >= 1) {
				var team_name = args[0].toLowerCase().rangeUpper(0, 1);
				var players = arrayTakeRange(args, 1);
				var sb = player.world.getScoreboard();
				if(players.length == 0) {
					players = [player.getName()];
				}
				var sbt = sb.getTeam(team_name);
				if(sbt != null) {
					for(p in players) {
						sbt.addPlayer(players[p]);
					}
					tellPlayer(player, "&aAdded "+players.length+" player(s) to team "+team_name);
				} else {
					tellPlayer(player, "&c"+team_name+" does'nt exists!");
				}
			} else {
				tellPlayer(player, "&cYou need to provide at leat a team name!")
			}
		}
	},
	'registerteam': function(player, args) {
		if(hasPermission(player, 'registerteam')) {
			if(args.length >= 1) {
				var w = player.world;
				var sb = w.getScoreboard();
				var add_teams = arrayTakeRange(args, 0, args.length);
				for(a in add_teams) {
					add_teams[a] = add_teams[a].toLowerCase().rangeUpper(0, 1);
					if(sb.getTeams().indexOf(add_teams[a]) == -1) {
						executeCommand(player, '/scoreboard teams add '+add_teams[a]);
						tellPlayer(player, strf('&aRegistered Scoreboard Team: '+add_teams[a]+'!'));
					} else {
						tellPlayer(player, strf('&cFailed to add team: '+add_teams[a]+' (Team already exists)'));
					}
				}
			} else {
				tellPlayer(player, strf('&cYou need to provide at least one team to add!'));
			}
		}
	},
	'perms': function(player, args) { //Permissions command
		if(hasPermission(player, 'perms')) { //Check permission
			var w = player.world;
			var data = w.getStoreddata();
			var sb = w.getScoreboard();
			
			if(args.length >= 1) {
				var permtype = args[0];
				switch(permtype) {
					case 'manage': { //manage permissions
						if(hasPermission(player, 'perms.manage')) {
							var operation = args[1];
							var cmd_id = null;
							
							if([//args.length >= 3 PERMISSION_ID FOR SOME ARGS
							'add',
							'remove',
							'register',
							'unregister',
							'addPlayer',
							'removePlayer',
							'setEnabled',
							'addList',
							'removeList',
							'addListItem',
							'removeListItem',
							'info'
							].indexOf(operation) != -1) {
								if(args.length >= 3) {
									cmd_id = args[2];
								} else {
									tellPlayer(player, [
										['You need to provide a permission id to perform this action!', 'red']
									]);
									return false;
								}
							}
							
							switch(operation) {
								case 'add': {
									if(hasPermission(player, 'perms.manage.add')) {
										if(args.length >= 4) {
											var new_sb_teams = arrayTakeRange(args, 3, args.length);
											for(ni in new_sb_teams) { new_sb_teams[ni] = new_sb_teams[ni].toString().toLowerCase().rangeUpper(0, 1); }
											if(addCommandPerm(data, cmd_id, new_sb_teams)) {
												tellPlayer(player, [
													["Successfully added team(s) \""+new_sb_teams.join(', ')+"\" to permission id: \""+cmd_id+"\"!", "green"]
												]);
											} else {
													tellPlayer(player, [
													['Permission id: "'+cmd_id+'" does not exists!', 'red']
												]);
											}
										} else {
											tellPlayer(player, [
												['You must provide at least one team to add!', 'red']
											]);
										}
									}
									break;
								}
								case 'remove': {
									if(hasPermission(player, 'perms.manage.remove')) {
										if(args.length >= 4) {
											var rem_sb_teams = arrayTakeRange(args, 3, args.length);
											for(ri in rem_sb_teams) { rem_sb_teams[ri] = 	rem_sb_teams[ri].toString().toLowerCase().rangeUpper(0, 1); }
											if(removeCommandPerm(data, cmd_id, rem_sb_teams)) {
												tellPlayer(player, [
													['Successfully removed team(s) "'+rem_sb_teams.join(', ')+'" from permission id: "'+cmd_id+'"', 'green']
												]);
											} else {
												tellPlayer(player, [
													['Permission id: "'+cmd_id+'" does not exists!', 'red']
												]);
											}
											
										} else {
											tellPlayer(player, [
												['You must provide at least one team to remove!', 'red']
											]);
										}
									}
									break;
								}
								case 'register': {
									if(hasPermission(player, 'perms.manage.register')) {
										if(data.get('cmd_permission_'+cmd_id) == null) {
											registerCommandPerm(data, cmd_id);
											executeCommand(player, "/tellraw "+player.getName()+" "+rawformat([
												["Succesfully registered permission id: "+cmd_id+"!", "green"]
											]));
										} else {
											executeCommand(player, "/tellraw "+player.getName()+" "+rawformat([
												['permission id already exists!', 'red']
											]));
										}
									}
									break;
								}
								case 'unregister': {
									if(hasPermission(player, 'perms.manage.unregister')) {
										if(data.get('cmd_permission_'+cmd_id) != null) {
											if(unregisterCommandPerm(data, cmd_id)) {
												tellPlayer(player, [
													["Succesfully deleted permission id: "+cmd_id+"!", "green"]
												]);
											}
										} else {
											tellPlayer(player, [
												['Permission id does not exists in data!', 'red']
											]);
										}
									}
									break;
								}
								case 'info': {
									if(hasPermission(player, 'perms.manage.info')) {
										if(args.length >= 3) {
											var show_perms = arrayTakeRange(args, 2, args.length);
											for(l in show_perms) {
												var cp = getCommandPerm(data, show_perms[l]);
												if(cp !== false) {
													storytellPlayer(player, cp);
												}
											}
										}
									}
									break;
								}
								case 'list': {
									if(hasPermission(player, 'perms.manage.list')) {
										var pmatches = [];
										if(args.length >= 3) { pmatches = arrayTakeRange(args, 2, args.length); }
										//List Perm IDS
										var dk = data.getKeys();
										tellPlayer(player, strf('&l[=======] &a&lAlteria Permission Ids &l[=======]'));
										var regkeys = [];
										for(k in dk) {
											var key = dk[k];
											if( (key.match(/cmd_permission_([\w\.]+)/) || []).length > 0 ) {
												//Is perm ID
												var l_id = key.replace(/cmd_permission_([\w\.]+)/, '$1');
												regkeys.push(l_id);
											}
										}
										
										if(pmatches.length > 0) {
											var nregk = [];
											for(pm in pmatches) {
												for(rgk in regkeys) {
													if(regkeys[rgk].indexOf(pmatches[pm]) > -1) {
														if(nregk.indexOf(regkeys[rgk]) == -1) {
															nregk.push(regkeys[rgk]);
														}
													}
												}
											}
											regkeys = nregk;
										}
										
										regkeys.sort();
										for(rk in regkeys) {
											tellPlayer(player, strf(' - '+regkeys[rk]));
										}
									
									}
									break;
								}
								case 'listPlayer': {
									if(hasPermission(player, 'perms.manage.listPlayer')) {
										if(args.length >= 3) {
											var a_lplayers = arrayTakeRange(args, 2, args.length);
											var lplayers = {};
											//Setup retrieve player perms
											for(aj in a_lplayers) { lplayers[a_lplayers[aj]] = []; }
											var dkeys = data.getKeys();
											for(dk in dkeys) {//Loop data
												var dkey = dkeys[dk];
												if( (dkey.match(/cmd_permission_([\w\.]+)/g) || []).length > 0 ) {//Is permission key
													var dperm = JSON.parse(data.get(dkey));
													//Check for players
													for(aj in a_lplayers) {
														apj = a_lplayers[aj];
														var d_id = dkey.replace(/cmd_permission_([\w\.]+)/g, '$1');
														if(dperm.whitelist.indexOf(apj) > -1 && lplayers[apj].indexOf(d_id) == -1) {
															lplayers[apj].push(d_id);
														}
														var sbt = sb.getPlayerTeam(apj);
														if(sbt != null) {
															if(dperm.permitted.indexOf(sbt.getDisplayName()) > -1 && lplayers[apj].indexOf(d_id) == -1) {
																lplayers[apj].push([d_id, sbt.getName()]);
															}
														}
													}
												}
											}
											
											for(l in lplayers) {
												var lplayer = lplayers[l];
												tellPlayer(player, [
													['Permissions for player: ', 'yellow'],
													[l.toString(), 'red'],
												]);
												for(prm in lplayer) {
													if(typeof(lplayer[prm]) == 'string') {
														tellPlayer(player, [
															[' - ', 'yellow'],
															[lplayer[prm].toString(), 'blue', 1]
														]);
													} else {
														tellPlayer(player, [
															[' - ', 'yellow'],
															[lplayer[prm][0].toString(), 'blue', 1],
															[' (Permitted via team ', 'yellow'],
															[lplayer[prm][1].toString(), 'dark_aqua', 1],
															[")", 'yellow'],
														]);
													}
												}
												tellPlayer(player, [[""]]);
											}
										} else {
											tellPlayer(player, [
												['You must provide at least one player!', 'red']
											]);
										}
									}
									break;
								}
								case 'addPlayer': {
									if(hasPermission(player, 'perms.manage.addPlayer')) {
										if(args.length >= 4) {
											var new_players = arrayTakeRange(args, 3, args.length);
											if(addPlayerCommandPerm(data, cmd_id, new_players)) {
												tellPlayer(player, [
													['Successfully added player(s) "'+new_players.join(', ')+'" to permission id: "'+cmd_id+'"!', 'green']
												]);
											} else {
												tellPlayer(player, [
													['Permission id: "'+cmd_id+'" does not exists!', 'red']
												]);
											}
										} else {
											tellPlayer(player, [
												['You must provide at least one player to add!', 'red']
											]);
										}
									}
									break;
								}
								case 'removePlayer': {
									if(hasPermission(player, 'perms.manage.removePlayer')) {
										if(args.length >= 4) {
											var rem_players = arrayTakeRange(args, 3, args.length);
											if(removePlayerCommandPerm(data, cmd_id, rem_players)) {
												tellPlayer(player, [
													['Successfully removed player(s) "'+rem_players.join(', ')+'" from permission id: "'+cmd_id+'"', 'green']
												]);
											} else {
												tellPlayer(player, [
													['Permission id: "'+cmd_id+'" does not exists!', 'red']
												]);
											}
										} else {
											tellPlayer(player, [
												['You must provide at least one player to remove!', 'red']
											]);
										}
									}
									break;
								}
								case 'setEnabled': {
									if(hasPermission(player, 'perms.manage.setEnabled')) {
										var val = args[3];
										if(['true', 'false'].indexOf(val) == -1) {
											tellPlayer(player, [
												['You must either provide ', 'red'],
												['true', 'red', 0, 0, 1],
												[' or ', 'red'],
												['false', 'red', 0, 0, 1],
												['!', 'red']
											]);
											return false;
										} else {
											var ep = getPerm(data, cmd_id);
											if(ep != null) {
												ep.enabled = (val == 'true');
												savePermAs(data, ep, cmd_id);
												tellPlayer(player, [
													[(ep.enabled ? 'Enabled':'Disabled')+' Permission: ', 'yellow'],
													[cmd_id, 'blue', 1],
												]);
											} else {
												tellPlayer(player, [
													['Permission id "'+cmd_id+'" doesn\'t exists!', 'red']
												]);
												return false;
											}
										}
									}
									break;
								}
								case 'reload': {
									if(hasPermission(player, 'perms.manage.reload')) {
										var ff = reloadPermissions(data);
										for(f in ff) {
											tellPlayer(player, [
												['Reloaded permission: "', 'green'],
												[ff[f].toString(), 'blue', 1],
												['"!', 'green'],
											]);
										}
									}
									break;
								}
								case 'addList': {
									if(hasPermission(player, 'perms.manage.addList')) {
										if(args.length >= 4) {
											var lists = arrayTakeRange(args, 3, args.length);
											for(ll in lists) {
												if(addPermMetaList(data, cmd_id, lists[ll])) {
													tellPlayer(player, [
														['Added list "'+lists[ll]+'" to permission "'+cmd_id+'"!', 'green']
													]);
												} else {
													tellPlayer(player, [
														['Error adding list "'+lists[ll]+'"!', 'red']
													]);
												}
											}
										} else {
											tellPlayer(player, [
												['You need to provide an list id!', 'red']
											]);
										}
									}
									break;
								}
								case 'removeList': {
									if(hasPermission(player, 'perms.manage.removeList')) {
										if(args.length >= 4) {
											var lists = arrayTakeRange(args, 3, args.length);
											for(ll in lists) {
												if(removePermMetaList(data, cmd_id, lists[ll])) {
													tellPlayer(player, [
														['Deleted list "'+lists[ll]+'" from permission "'+cmd_id+'"!', 'green']
													]);
												} else {
													tellPlayer(player, [
														['Something went wrong deleting list "'+lists[ll]+'" from permission "'+cmd_id+'"', 'red']
													]);
												}
											}
										}
									}
									break;
								}
								case 'addListItem': {
									if(hasPermission(player, 'perms.manage.addListItem')) {
										if(args.length >= 5) {
											var addItems = arrayTakeRange(args, 4, args.length);
											addPermMetaListItem(data, cmd_id, args[3], addItems);
											tellPlayer(player, [
												['Added "'+addItems.join(',')+'" to list "'+args[3]+'" in permission "'+cmd_id+'"!', 'green']
											]);
										} else {
											tellPlayer(player, [
												['You must provide a list ID and at least one item to add!', 'red']
											]);
										}
									}
									break;
								}
								case 'removeListItem': {
									if(hasPermission(player, 'perms.manage.removeListItem')) {
										if(args.length >= 5) {
											var remItems = arrayTakeRange(args, 4, args.length);
											removePermMetaListItem(data, cmd_id, args[3], remItems);
											tellPlayer(player, [
												['Removed "'+remItems.join(',')+'" to list "'+args[3]+'" in permission "'+cmd_id+'"!', 'green']
											]);
										} else {
											tellPlayer(player, [
												['You must provide a list ID and at least one item to remove!', 'red']
											]);
										}
									}
									break;
								}
								case 'help':
								case '?': {
									if(hasPermission(player, 'perms.manage.help')) {
										tellPlayer(player, [
											['[========] ', 'white', 0, 1],
											['Alteria Permissions Help', 'green', 0, 1],
											[' [========]', 'white', 0, 1],
										]);
										tellPlayer(player, [
											['!perms manage register <permission_id> [...score_board_teams]', 'red'],
											[' - Registers a permission where teams and players can be assigned to. Second argument is for providing teams and is optional, as you can add teams on a later moment', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage unregister <permission_id>', 'red'],
											[' - Removes a permission from the Alteria registry. Don\'t delete anything unless you have added a custom one yourself and want to delete that!', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage add <permission_id> <...scoreboard_teams>', 'red'],
											[' - Adds a certain permission to teams. You can apply the permissions to multiple teams at once by dividing the team-names with spaces.', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage addPlayer <permission_id> <...players>', 'red'],
											[' - Adds a certain permission to players, if you want to make exceptions, otherwise keep using teams to maintain full overview.', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage remove <permission_id> <...scoreboard_teams>', 'red'],
											[' - Removes a certain permission from teams.', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage removePlayer <permission_id> <...players>', 'red'],
											[' - Removes a certain permission from players.', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage setEnabled <permission_id> <true|false>', 'red'],
											[' - Enables or disables a permission. If disabled, there will not be checked for this permission, so everyone \'has\' the permission. Be cautious disabling sensitive permissions!', 'yellow']
										]);
										tellPlayer(player, [
											['!perms manage list [...matches]', 'red'],
											[' - Lists all permission ids in a list and if at least one match is given, it will only show permissions that matches', 'yellow']
										]);
										tellPlayer(player, strf('&c!perms manage info <...permission_ids>&e - Gives all the info you need to know about every given permission id.'));
										tellPlayer(player, [
											['!perms manage listPlayer <...player_names>', 'red'],
											[' - Gives info about every given players\' permissions.', 'yellow']
										]);
										tellPlayer(player, strf('&c!perms manage addList <permission_id> <l'));
									}
									break;
								}
								default: {
									tellPlayer(player, [
										["Type '!perms manage help' or '!perms manage ?' for more info."]
									]);
								}
							}
						}
						break;
					}
					case 'item': { //Set item permission
						
						break;
					}
					case 'help':
					case '?': {
						if(hasPermission(player, 'perms.help')) {
							storytellPlayer(player, [
								[
									['[========] ', 'white', 0, 1],
									['Alteria Permissions Help', 'yellow', 0, 1],
									['[========] ', 'white', 0, 1],
								],
								[
									['!perms manage '+permtype, 'red'],
									[' - Shows help for managing permissions']
								],
							]);
						}
						break;
					}
					default: {
						tellPlayer(player, [
							["Unknown action '"+permtype+"'. Use \"!perms ?\" or \"!perms help\" for more info", "red"]
						]);
						break;
					}
				}
			} else {
				tellPlayer(player, [
					["Use \"!perms ?\" or \"!perms help\" for more info", "red"]
				]);
			}
		}
	},
	'playerstats': function(player, args) {
		if(hasPermission(player, 'playerstats')) {}
	},
	'stats': function(player, args) {
		if(hasPermission(player, 'stats', false)) {
			var showstats = [];
			if(args.length == 0) {
				showstats = _SKILLS;
			} else if(args.length > 0) {
				for(i in args) {
					var arg = args[i].toLowerCase().rangeUpper(0, 1);
					for(n in skill_names) {
						if( (skill_names[n].match(new RegExp(arg, 'g')) || []).length > 0 ) {
							if(showstats.indexOf(_SKILLS[n]) == -1) {
								showstats.push(_SKILLS[n]);
								break;
							}
						}
					}
				}
			}
			var sk = getSkills(player, showstats);
			//Output player skills
			var pstat = (player.getName()+"'s Stats");
			executeCommand(player, '/tellraw '+player.getName()+' '+rawformat([
				['[==========] ', 'white'],
				[pstat.padMiddle(" ", 25), 'red', 0, 1],
				[' [==========]', 'white'],
			]));
			var sb = player.world.getScoreboard();
			for(i in sk) {
				var skn = [];
				if(_SKILLS.indexOf(sk[i].id) != -1) {
					var skillname = skill_names[_SKILLS.indexOf(sk[i].id)];
					var skillxp_id = xp_stats[_SKILLS.indexOf(sk[i].id)];
					
					var so = sb.getObjective(skillxp_id);
					if(so != null) {
						var ps = so.getScore(player.getName());
						if(ps != null) {
							skn = getRawSkillString(skillname, sk[i].level, ps.getValue());
						}
					}
					
					
				}
				
				if(skn.length > 0) {
					executeCommand(player, '/tellraw '+player.getName()+' '+rawformat(skn));
				}
			}
		}
	},
	'region': function(player, args) {
		if(hasPermission(player, "region")) {
			var w = player.world;
			var data = w.getStoreddata();
			
			if(args.length >= 1) {
				var regcmd = args[0];

				switch(regcmd) {
					case 'add': {
						if(hasPermission(player, "region.add")) {
							if(args.length >= 2) {
								var rgns = arrayTakeRange(args, 1, args.length);
								for(i in rgns) {
									var rgn_name = rgns[i];
									var _rgn = addRegion(data, rgns[i]);
									_rgn.dimension = player.world.getDimension().getId();
									saveRegion(data, _rgn);
									tellPlayer(player, [
										['Successfully created region "'+rgn_name+'"', 'green']
									]);
								}
							} else {
								tellPlayer(player, [
									['You must provide a name for the region!', 'red']
								]);
							}
						}
						break;
					}
					case 'remove': {
						if(hasPermission(player, "region.remove")) {
							if(args.length >= 2) {
								var rgns = arrayTakeRange(args, 1, args.length);
								for(i in rgns) {
									if(removeRegion(data, rgns[i])) {
										tellPlayer(player, [
											['Successfully removed region "'+rgns[i]+'"', 'green']
										]);
									} else {
										tellPlayer(player, [
											['Region "'+rgns[i]+'" doesn\'t exists!', 'red']
										]);
									}
								}
							} else {
								tellPlayer(player, [
									['You must provide at least one region to delete!', 'red']
								])
							}
						}
						break;
					}
					case 'extendVert': {
						if(hasPermission(player, 'region.extendVert')) {
							if(args.length >= 2) {
								var regg = getRegion(data, args[1]);
								if(regg != null) {
									regg.pos.y1 = 0;
									regg.pos.y2 = 255;
									saveRegion(data, regg);
									tellPlayer(player, strf("&aExtended region '"+regg.name+"' vertically!"));
								} else {
									tellPlayer(player, strf("&cRegion '"+args[1]+"' does not exists!"));
								}
							} else {
								tellPlayer(player, strf("&cYou need to provide a region name!"))
							}
						}
						break;
					}
					case 'setPos1':
					case 'setPos2': {
						var posnum = (regcmd == 'setPos1' ? 1 : 2);
						if(hasPermission(player, "region.set.pos"+posnum)) {
							if(args.length >= 2) {
								var pr_id = args[1];
								var plpos = player.getPos();
								var pregion = getRegion(data, pr_id);
								if(pregion != null) {
									var xyz = ['x','y','z'];
									var nw = [];
									for(a in xyz) {
										pregion.pos[xyz[a]+posnum] = plpos['get'+xyz[a].toUpperCase()]();
										nw.push(plpos['get'+xyz[a].toUpperCase()]());
									}
									data.put('region_'+pr_id, JSON.stringify(pregion));
									tellPlayer(player, strf('&aSet '+pr_id+' position #'+posnum+' to: '+nw.join(', ')+'!'));
									
								}
							} else {
								tellPlayer(player, strf('&cYou need to provide a region name!'));
							}
						}
						break;
					}
					case 'set': {
						if(hasPermission(player, "region.set")) {
							if(args.length >= 4) {
								var rg_name = args[1];
								var rg_key = args[2];
								var rg_val = args[3];
								var allowed_keys = [
									'enterText',
									'leaveText',
									'salePrice',
									'rentPeriod',
									'maxRentPeriod',
									'rentCredit',
									'forSale',
									'owner',
									'dimension'
								];
								var ak = allowed_keys.indexOf(rg_key);
								if(ak != -1) {
									if(hasPermission(player, "region.set."+allowed_keys[ak])) {
										if(rg_key == 'forSale') {
											rg_val = (rg_val == 'true');
										}
										if(rg_key == 'salePrice' || rg_key == 'dimension') {
											if(rg_val.cInt() != null) {
												rg_val = rg_val.cInt();
											}
										}
										if(rg_key == 'rentPeriod' || rg_key == 'maxRentPeriod' || rg_key == 'rentCredit') {
											rg_val = getStringTime(rg_val.toString());
											if(rg_key == 'rentCredit') {
												rg_val += new Date().getTime();
											}
										}
										var reg = getRegion(data, rg_name);
										reg[allowed_keys[ak]] = rg_val;
										data.put('region_'+rg_name, JSON.stringify(reg));
										tellPlayer(player, strf("&aSet '"+rg_key+"' to '"+rg_val+"' in region '"+rg_name+"'!"));
									}
								} else {
									tellPlayer(player, strf("&cUnknown region property \""+rg_key+"\"!"));
								}
							} else {
								tellPlayer(player, strf("&eProper Usage: &c!region set <region_name> <property_name> <new_value>"));
							}
						}
						break;
					}
					case 'list': {
						if(hasPermission(player, 'region.list')) {
							var mt = [];
							if(args.length >= 2) { mt = arrayTakeRange(args, 1, args.length); }
							
							
							tellPlayer(player, strf('&l[=======] &a&lAlteria Regions &l[=======]'));
							var showkeys = [];
							var dkeys = data.getKeys();
							for(dk in dkeys) {
								var dkey = dkeys[dk];
								if( (dkey.match(/region_([\w\.]+)/g) || []).length > 0 ) {
									var rgn_id = dkey.replace(/region_([\w\.])/g, '$1');
									if(showkeys.indexOf(rgn_id) == -1) {
										if(mt.length > 0) {
											for(mm in mt) {
												if(occurrences(rgn_id, mt[mm]) > 0 && showkeys.indexOf(rgn_id) == -1) {
													showkeys.push(rgn_id);
												}
											}
										} else {
											showkeys.push(rgn_id);
										}
									}
									//tellPlayer(player, strf(' - '+rgn_id));
								}
							}
							showkeys.sort();
							for(ss in showkeys) {
								tellPlayer(player, strf(' - '+showkeys[ss]));
							}
						
						}
						break;
					}
					case 'info': {
						if(hasPermission(player, 'region.info')) {
							if(args.length >= 2) {
								var sregions = arrayTakeRange(args, 1, args.length);
								
								var rgi = [];
								for(s in sregions) {
									tellPlayer(player, strf('&l[=======] &a&lAlteria Region Info &l[=======]'));
									var sregion = getRegion(data, sregions[s]);
									if(sregion != null) {
										rgi.push(strf('&eRegion Info: &9&o'+sregion.name));
										rgi.push(strf('&eEnter Text: &r'+sregion.enterText));
										rgi.push(strf('&eLeave Text: &r'+sregion.leaveText));
										rgi.push(strf('&eOwner: '+(sregion.owner == null ? '&a&lAlteria':'&r'+sregion.owner)));
										if(sregion.owner != null) {
											rgi.push(strf('&eRent time left: &6&o'+getTimeString(sregion.rentCredit - new Date().getTime())));
										} else {
											rgi.push(strf('&eFor Sale: &c'+sregion.forSale.toString()));
										}
										
										rgi.push(strf('&eCost per &6&o'+getTimeString(sregion.rentPeriod)+'&e: &l&2'+sregion.salePrice+' &eCoins'));
										rgi.push(strf('&eMax rent time: &6&o'+getTimeString(sregion.maxRentPeriod)));
										
										var valid = isValidRegion(sregion, true);
										rgi.push(strf('&eDimension: &c'+sregion.dimension));
										rgi.push(strf('&ePosition: '+(valid!=true?'(Region not physical yet, define '+valid.join(',')+' to make the region existend)':'')));
										for(ps in sregion.pos) {
											rgi.push(strf('&e - '+ps+': &c'+sregion.pos[ps]));
										}
										storytellPlayer(player, rgi);
									}
								}
							} else {
								tellPlayer(player, strf('&cYou need to provide at least one region name!'));
							}
						}
						break;
					}
					case 'rent': {
						if(hasPermission(player, 'region.rent')) {
							if(args.length >= 2) {
								var reg_id = args[1];
								var regg = getRegion(data, reg_id);
								if(regg != null) {
									if(regg.forSale || regg.owner == player.getName()) {
										if(regg.owner == null || regg.owner == player.getName()) {
											if(player.inventoryItemCount('minecraft:gold_nugget', -1) >= regg.salePrice) {
												if(regg.owner == null) {
													//new rent
													regg.owner = player.getName();
													regg.rentCredit = new Date().getTime();
													
												}
												regg.forSale = false;
												if(regg.rentCredit+regg.rentPeriod <= new Date().getTime()+regg.maxRentPeriod) {
													regg.rentCredit += regg.rentPeriod;
													player.removeItem('minecraft:gold_nugget', -1, regg.salePrice);
													saveRegion(data, regg);
													tellPlayer(player, strf('&aSuccessfully rented region!'));
												} else {
													tellPlayer(player, strf('&cYou have reached maximum renting time!'));
												}
												
												
											} else {
												tellPlayer(player, strf('&cYou don\'t have enough coins!'));
											}
											
											
										} else {
											tellPlayer(player, strf('&cThis region is already owned!'));
										}
									} else {
										tellPlayer(player, strf('&cThis region is not for sale!'))
									}
								} else {
									tellPlayer(player, strf('&cRegion does not exists!'));
								}
							} else {
								tellPlayer(player, strf('&cYou need to provide an region name!'));
							}
						}
					}
				}
			}
		}
	},
	'worth': function(player, args) {
		player.world.broadcast('worth: '+args.join(', ').toString());
	},
};

var _CMD_IDS = [];

var _MAGICMETHODS = [
	'__desc',
	'__run',
	'__help'
];


function executeXCommand(player, cmd) {
	var msg = cmd;
	var retval = false;
	if(msg.substr(0, 1) == '!') {
		msg = msg.substr(1, msg.length-1);
		var args = msg.split(" ");
		
		var cmd = _COMMANDS;
		var cancel = false;
		
		for(i in args) {
			var arg = args[i];
			//Is not magic method?
			if(_MAGICMETHODS.indexOf(arg) == -1) {
				//Check subcommands
				if(typeof(cmd[arg.toString()]) != typeof(undefined)) {
					cmd = cmd[arg.toString()];
				} else {
					tellPlayer(player, [
						['Cannot find this Alteria Command!', 'red']
					]);
				
					cancel = true;
					break;
				}
				
				//isRunnable
				if(typeof(cmd) == 'function') {
					var cmd_args = args.slice(i+1, args.length-i);
					retval = cmd(player, cmd_args) || false;
					break;
				}
			} else {
				//Is magic method
				var mm = _MAGICMETHODS[_MAGICMETHODS.indexOf(arg)];
				//if(mm == '__help'
				
				cancel = true;
				break;
			}
		
		}
		if(typeof(cmd.__run) != typeof(undefined)) {
			cmd.__run(player);
		}
		
		//has not selected subcommand?
		if(typeof(cmd) != 'function' && !cancel) {
			executeCommand(player, '/tellraw '+player.getName()+' '+rawformat([
				['Subcommands: '+Object.keys(cmd).join(', '), 'white']
			]));
		}
	}
	
	return retval;
}




function sendMail(data, from, to, title, msg) {
	if(typeof(title) == typeof(undefined)) { var title = ''; }
	if(typeof(msg) == typeof(undefined)) { var msg = ''; }
	var mail = {
		'from': from,
		'to': to,
		'title': title.toString(),
		'msg': msg.toString(),
		'time': new Date().getTime()
	};
	
	
	data.put('mail_'+uniqid(), JSON.stringify(mail));
	
}

function deleteMail(data, toPlayer) {
	var dkeys = data.getKeys();
	for(dk in dkeys) {
		var dkey = dkeys[dk];
		if( (dkey.match(/mail_[\w]+/g) || []).length > 0 ) {
			//Is Mail
			var mail = JSON.parse(data.get(dkey));
			if(mail.to == toPlayer) {
				//If it is players' mail
				data.remove(dkey);
			}
		}
	}
}

function getMail(data, player) {
	var mails = [];
	var dkeys = data.getKeys();
	for(dk in dkeys) {
		var dkey = dkeys[dk];
		
		if( (dkey.match(/mail_[\w]+/g) || []).length > 0 ) {
			//Is Mail
			
			var mail = JSON.parse(data.get(dkey));
			if(mail.to == player.getName()) {
				mails.push(mail);
			}
		}
	}
	return mails;
}

//Registers permission
function registerCommandPerm(data, command_id, perm_groups, meta, whitelist, overwrite) {
	if(typeof(perm_groups) == typeof(undefined)) { var perm_groups = null; }
	if(typeof(meta) == typeof(undefined)) { var meta = null; }
	if(typeof(whitelist) == typeof(undefined)) { var whitelist = null; }
	if(typeof(overwrite) == typeof(undefined)) { var overwrite = false; }
	if(perm_groups == null) { perm_groups = ['Owner', 'Admin', 'Developer']; }
	if(meta == null) { meta = {}; }
	if(whitelist == null) { whitelist = []; }
	var newperms = perm_groups;
	//Check if parent has group already
	var pars = getCommandPermParents(data, command_id);
	for(p in pars) {
		var ppar = data.get('cmd_permission_'+pars[p].toString());
		if(ppar != null) {
			var jpar = JSON.parse(ppar);
			
			
			for(g in perm_groups) {
				if(jpar.permitted.indexOf(perm_groups[g]) != -1) {
					newperms = removeFromArray(newperms, perm_groups[g]);
				}
			}
		}
	}
	
	
	//Register if not exists
	var regPerm = JSON.stringify({
		"id": command_id.toString(),
		"permitted": newperms,
		"whitelist": whitelist,
		"metadata": meta,
		"enabled": true
	});
	if(overwrite) {
		data_overwrite(data, 'cmd_permission_'+command_id.toString(), regPerm);
	} else {
		data_register(data, 'cmd_permission_'+command_id.toString(), regPerm);
	}
	return getPerm(data, command_id);
}

//Deletes permission
function unregisterCommandPerm(data, command_id) {
	if(data.get('cmd_permission_'+command_id.toString()) != null) {
		data.remove('cmd_permission_'+command_id.toString());
		return true;
	}
	return false;
}

//Get permission as JSON Object
function getPerm(data, id) {
	var p = data.get('cmd_permission_'+id.toString());
	if(p != null) { return JSON.parse(p); }
	return null;
}

//Saves permission object as id
function savePermAs(data, perm, id) {
	perm.id = id;
	data.put('cmd_permission_'+id.toString(), JSON.stringify(perm));
}

//Adds a meta list
function addPermMetaList(data, perm_id, list_name, output_name) {
	if(typeof(output_name) == typeof(undefined)) { var output_name = null; }
	var p = getPerm(data, perm_id);
	if(p != null) {
		if(typeof(p.metadata[list_name]) == typeof(undefined)) {
			p.metadata[list_name] = {
				"name": list_name,
				"displayName": (output_name == null ? list_name : output_name),
				"items": []
			};
		} else { return false; }
		
		savePermAs(data, p, perm_id);
		return true;
	}
	
	return false;
}

//Add items to meta list
function addPermMetaListItem(data, perm_id, list_name, items) {
	if(typeof(items) == 'string') { items = [items]; }
	var p = getPerm(data, perm_id);
	if(p != null) {
		if(typeof(p.metadata[list_name]) != typeof(undefined)) {
			for(i in items) {
				if(typeof(p.metadata[list_name].items) != typeof(undefined)) {
					if(p.metadata[list_name].items.indexOf(items[i]) == -1) {
						p.metadata[list_name].items.push(items[i]);
					}
				}
			}
		}
		savePermAs(data, p, perm_id);
	}
}

//Remove a meta list
function removePermMetaList(data, perm_id, list_name) {
	var p = getPerm(data, perm_id);
	if(p != null) {
		if(typeof(p.metadata[list_name]) != typeof(undefined)) {
			delete p.metadata[list_name];
			savePermAs(data, p, perm_id);
			return true;
		}
	}
	return false;
}

//Delete items to meta list
function removePermMetaListItem(data, perm_id, list_name, items) {
	if(typeof(items) == 'string') { items = [items]; }
	var p = getPerm(data, perm_id);
	if(p != null) {
		if(typeof(p.metadata[list_name]) != typeof(undefined)) {
			var newItems = [];
			for(i in p.metadata[list_name].items) {
				if(items.indexOf(p.metadata[list_name].items[i]) == -1 && newItems.indexOf(p.metadata[list_name].items[i]) == -1) {
					newItems.push(p.metadata[list_name].items[i]);
				}
			}
			p.metadata[list_name].items = newItems;
		}
		savePermAs(data, p, perm_id);
	}
}

//Reload permissions
function reloadPermissions(data) {
	var affected = [];
	var dkeys = data.getKeys();
	for(dk in dkeys) {
		var dkey = dkeys[dk];
		if( (dkey.match(/cmd_permission_([\w\.]+)/g) || []).length > 0 ) {
			var pID = dkey.replace(/cmd_permission_([\w\.]+)/g, '$1');
			//Is permission
			var oldPerm = getPerm(data, pID);
			var newPerm = registerCommandPerm(data, pID, oldPerm.permitted, oldPerm.metadata, oldPerm.whitelist, true);
			affected.push(pID);
			savePermAs(data, newPerm, pID);
		}
	}
	
	return affected;
}

//Gets all players and teams as rawformat from a certain permission
function getCommandPerm(data, command_id) {
	if(data.get('cmd_permission_'+command_id) != null) {
		var jp = JSON.parse(data.get('cmd_permission_'+command_id));
		//print(JSON.stringify(jp));
		var pars = getCommandPermParents(data, command_id);
		var parpteams = [];
		var parpl = [];
		
		cpo = [];
		cpo.push([
			['[=======] ', 'white', 0, 1],
			['Alteria Permission Info', 'green', 0, 1],
			[' [=======]', 'white', 0, 1],
		]);
		cpo.push([
			['Permission id: ', 'yellow'],
			[command_id, 'blue', 1]
		]);
		cpo.push([
			['Enabled: ', 'yellow'],
			[jp.enabled.toString(), (jp.enabled ? 'green' : 'red'), 0, 1]
		]);
		cpo.push([
			['Teams: ', 'yellow']
		]);
		
		//Output parent teams
		for(i in pars) { //Loop parents
			var par = pars[i];
			if(data.get('cmd_permission_'+par) != null) {
				var parperm = JSON.parse(data.get('cmd_permission_'+par));
				for(p in parperm.permitted) {//Loop parent teams
					var parpermit = parperm.permitted[p];
					
					if(jp.permitted.indexOf(parpermit) == -1) {
						parpteams.push([parpermit, par]);
					}
				}
				for(p in parperm.whitelist) {//Loop parent players
					var parwl = parperm.whitelist[p];
					
					if(jp.whitelist.indexOf(parwl) == -1) {
						parpl.push([parwl, par]);
					}
				}
			}
		}
		
		
		
		//Output teams
		jp.permitted.sort();
		for(i in jp.permitted) {
			cpo.push([[' - '+jp.permitted[i], 'white']]);
		}
		parpteams.sort();
		//Output parent teams
		for(i in parpteams) {
			cpo.push([
				[' - '+parpteams[i][0], 'white'],
				[' - Added by parent permission: ', 'yellow'],
				[parpteams[i][1], 'blue', 1]
			]);
		}
		
		cpo.push([
			['Players: ', 'yellow']
		]);
		jp.whitelist.sort();
		//Output Players
		for(i in jp.whitelist) {
			cpo.push([[' - '+jp.whitelist[i], 'white']]);
		}
		parpl.sort();
		//Output Parent players
		for(i in parpl) {
			cpo.push([
				[' - '+parpl[i][0], 'white'],
				[' - Added by parent permission: ', 'yellow'],
				[parpl[i][1], 'blue', 1]
			]);
		}
		
		cpo.push([
			['Metadata: ', 'yellow']
		]);
		for(i in jp.metadata) {
			var metalist = jp.metadata[i].items;
			cpo.push([
				[' - Metalist: ', 'yellow'],
				[i.toString(), 'dark_green', 1]
			]);
			for(j in metalist) {
				cpo.push([
					['    - ', 'yellow'],
					[metalist[j].toString(), 'gold', 1]
				]);
			}
		}
		
		return cpo;
	}
	
	return false;
}

function getCommandPermParents(data, command_id) {
	var par = [];
	var keys = [];
	var dkeys = data.getKeys();
	var cmd = command_id.split('.');
	for(i in dkeys) {
		//Is perm key
		if( (dkeys[i].match(/cmd_permission_([\w\.]+)/) || []).length > 0 ) {
			//Get perm key and split it
			var dkey = dkeys[i].replace(/cmd_permission_([\w\.]+)/, "$1");
			var icmd = dkey.split('.');
			var isParent = false;
			if(cmd.length > icmd.length) {
				isParent = true;
				for(ic in icmd) {
					if(icmd[ic] != cmd[ic]) {
						isParent = false;
						break;
					} 
				}
			}
			if(isParent) { par.push(dkey); }
		}
	}
	
	return par;
}
//Add team(s) to permission
function addCommandPerm(data, command_id, sb_team_name) {
	if(typeof(sb_team_name) == 'string') { var sb_team_name = [sb_team_name]; }
	if(data.get('cmd_permission_'+command_id.toString()) != null) {
		var cperm = JSON.parse(data.get('cmd_permission_'+command_id.toString()));
		if(cperm.permitted == null) { cperm.permitted = []; }
		for(i in sb_team_name) {
			//is team not added yet
			var stm = sb_team_name[i].toString().toLowerCase().rangeUpper(0, 1);
			
			if(cperm.permitted.indexOf(stm) == -1) {
				cperm.permitted.push(stm);
			}
		}
		data.put('cmd_permission_'+command_id.toString(), JSON.stringify(cperm));
		return true;
	}
	return false;
}

//Add player(s) to permission
function addPlayerCommandPerm(data, command_id, player_names) {
	if(typeof(player_names) == 'string') { player_names = [player_names]; }
	var perm = data.get('cmd_permission_'+command_id.toString());
	if(perm != null) {
		var jperm = JSON.parse(perm);
		for(p in player_names) {
			jperm.whitelist.push(player_names[p]);
		}
		
		data.put('cmd_permission_'+command_id.toString(), JSON.stringify(jperm));
		return true;
	}
	
	return false;
}

//Enables/Disables permissions
function setEnabledCommandPerm(data, command_id, enabled) {
	if(typeof(enabled) == typeof(undefined)) { var enabled = true; }
	var perm = data.get('cmd_permission_'+command_id);
	if(perm != null) {
		var jperm = JSON.parse(perm);
		if(enabled == null) {
			jperm.enabled = !jperm.enabled;
		}
		jperm.enabled = enabled;
		data.put('cmd_permission_'+command_id, JSON.stringify(jperm));
		return true;
	}
	return false;
}

//Remove players from permission
function removePlayerCommandPerm(data, command_id, player_names) {
	if(typeof(player_names) == 'string') { player_names = [player_names]; }
	var perm = data.get('cmd_permission_'+command_id.toString());
	if(perm != null) {
		var jperm = JSON.parse(perm);
		jperm.whitelist = removeFromArray(jperm.whitelist, player_names);
		data.put('cmd_permission_'+command_id.toString(), JSON.stringify(jperm));
		return true;
	}
	
	return false;
}

//Remove teams from permission
function removeCommandPerm(data, command_id, sb_team_name) {
	if(typeof(sb_team_name) == 'string') { var sb_team_name = [sb_team_name]; }
	if(data.get('cmd_permission_'+command_id.toString()) != null) {
		var cperm = JSON.parse(data.get('cmd_permission_'+command_id.toString()));
		var newteams = []
		
		for(i in cperm.permitted) {
			var cpi = cperm.permitted[i].toString().toLowerCase().rangeUpper(0, 1);
			if(sb_team_name.indexOf(cpi) == -1) {
				newteams.push(cpi);
			}
		}
		cperm.permitted = newteams;
		data.put('cmd_permission_'+command_id.toString(), JSON.stringify(cperm));
		return true;
	}
	return false;
}

//Check if player has permission, or if player is in team with permission
function hasPermission(player, command_id, cancel_on_error, create_if_not_found, notify_not_permitted) {
	if(typeof(cancel_on_error) == typeof(undefined)) { var cancel_on_error = true; }
	if(typeof(create_if_not_found) == typeof(undefined)) { var create_if_not_found = true; }
	if(typeof(notify_not_permitted) == typeof(undefined)) { var notify_not_permitted = true; }
	var w = player.world;
	var sb = w.getScoreboard();
	var data = w.getStoreddata();
	//if(typeof(command_id) == 'string') { var command_id = [command_id]; }
	
	var perm = data.get('cmd_permission_'+command_id.toString());
	if(perm != null) {
		if(perm.enabled == false) { return true; }
		//print('Has Perm in data');
		var jperm = JSON.parse(perm);
		var pteam = sb.getPlayerTeam(player.getName());
		//if(jperm.permitted == null) { return true; }
		//if(jperm.permitted.length == 0) { return true; }
		//print(JSON.stringify(jperm));
		if(pteam != null) {//If player is in team
			//Player has team
			//print("IO: "+jperm.permitted.indexOf(pteam.getDisplayName()).toString());
			if(jperm.permitted.indexOf(pteam.getDisplayName()) != -1) {
				return true;
			}
			var pars = getCommandPermParents(data, command_id);
			
			for(p in pars) { //Loop permission parents
				var par = pars[p];
				if(data.get('cmd_permission_'+par) != null) {
					var parperm = JSON.parse(data.get('cmd_permission_'+par));
					if(parperm.permitted.indexOf(pteam.getDisplayName()) != -1) {
						return true;
					}
					if(parperm.whitelist.indexOf(player.getName()) != -1) {
						return true;
					}
				}
			}
		}
		if(jperm.whitelist.indexOf(player.getName()) != -1) { //If is whitelisted
			return true;
		}
		
		
		
	} else {
		if(create_if_not_found) {
			registerCommandPerm(data, command_id);
			return hasPermission(player, command_id, cancel_on_error, create_if_not_found, notify_not_permitted);
		}
		return !cancel_on_error;
	}
	
	if(notify_not_permitted) {
		tellPlayer(player, [
			['You don\'t have the sufficient permissions!', 'red']
		]);
	}
	return false;
}//=== REGION FUNCTIONS ===//
//Add region to data
function addRegion(data, region_name) {
	var region = {
		"name": region_name,
		"enterText": "",
		"leaveText": "",
		"dimension": 0,
		"pos": {
			"x1": null,
			"y1": null,
			"z1": null,
			"x2": null,
			"y2": null,
			"z2": null,
		},
		"salePrice": 768,
		"rentPeriod": getStringTime('2w'),
		"maxRentPeriod": getStringTime('6mon'),
		"lockdownTime": getStringTime('2w'),
		"forSale": false,
		"rentCredit": -1,
		"owner": null,
		"rules": {
			"strangersAllowed": true,
			"friends": [],
			"friendsCanAccessChests": false
		}
	};
	//REgister region
	saveRegion(data, region, region_name);
	//Register region permission
	var p_id = 'regions.'+region_name.toString();
	registerCommandPerm(data, p_id);
	registerCommandPerm(data, p_id+'.enter');
	registerCommandPerm(data, p_id+'.build');
	registerCommandPerm(data, p_id+'.self.build');
	registerCommandPerm(data, 'regions.'+region_name+'.set.pos1');
	registerCommandPerm(data, 'regions.'+region_name+'.set.pos2');
	registerCommandPerm(data, 'regions.'+region_name+'.set.enterText');
	registerCommandPerm(data, 'regions.'+region_name+'.set.leaveText');
	registerCommandPerm(data, 'regions.'+region_name+'.set.salePrice');
	registerCommandPerm(data, 'regions.'+region_name+'.set.rentPeriod');
	registerCommandPerm(data, 'regions.'+region_name+'.set.maxRentPeriod');
	registerCommandPerm(data, 'regions.'+region_name+'.set.rentCredit');
	registerCommandPerm(data, 'regions.'+region_name+'.set.forSale');
	registerCommandPerm(data, 'regions.'+region_name+'.set.owner');
	registerCommandPerm(data, 'regions.'+region_name+'.set.dimension');
	registerCommandPerm(data, 'regions.'+region_name+'.remove');
	registerCommandPerm(data, 'regions.'+region_name+'.info');
	registerCommandPerm(data, 'regions.'+region_name+'.rent');
	registerCommandPerm(data, 'regions.'+region_name+'.extendVert');


	return region;
}

function saveRegion(data, region_obj, region_name) {
	if(typeof(region_name) == typeof(undefined)) { var region_name = null; }
	if(region_name != null) {
		region_obj.name = region_name;
	}
	data.put('region_'+region_obj.name, JSON.stringify(region_obj));
}

//Remove region from data
function removeRegion(data, region_name) {
	if(data.get('region_'+region_name) != null) {
		data.remove('region_'+region_name);
		unregisterCommandPerm(data, 'regions.'+region_name);
		unregisterCommandPerm(data, 'regions.'+region_name+'.enter');
		unregisterCommandPerm(data, 'regions.'+region_name+'.build');
		unregisterCommandPerm(data, 'regions.'+region_name+'.remove');
		unregisterCommandPerm(data, 'regions.'+region_name+'.extendVert');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.pos1');unregisterCommandPerm(data, 'regions.'+region_name+'.set.pos2');unregisterCommandPerm(data, 'regions.'+region_name+'.set.enterText');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.leaveText');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.salePrice');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.rentPeriod');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.maxRentPeriod');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.rentCredit');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.forSale');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.owner');
		unregisterCommandPerm(data, 'regions.'+region_name+'.set.dimension');
		unregisterCommandPerm(data, 'regions.'+region_name+'.self.build');
		unregisterCommandPerm(data, 'regions.'+region_name+'.remove');
		unregisterCommandPerm(data, 'regions.'+region_name+'.info');
		unregisterCommandPerm(data, 'regions.'+region_name+'.rent');
		unregisterCommandPerm(data, 'regions.'+region_name+'.extendVert');

		return true;
	}
	return false;
}

function isValidRegion(region_obj, return_missing_keys) {
	if(typeof(return_missing_keys) == typeof(undefined)) { var return_missing_keys = false; }
	var mks = [];
	var isValid = true;
	for(k in region_obj.pos) {
		if(region_obj.pos[k] == null) {
			mks.push(k);
			isValid = false;
		}
	}
	
	if(isValid) { return true; }
	
	if(!return_missing_keys) {
		return false;
	} else {
		return mks;
	}
}

//Get region from data
function getRegion(data, region_name) {
	var region = data.get('region_'+region_name);
	if(region != null) {
		return JSON.parse(region);
	}
	
	return null;
}

//Set region rule
function setRegionRule(data, region_name, rule, value, _enum) {
	if(typeof(_enum) == typeof(undefined)) { var _enum = null; }
	var region = data.get('region_'+region_name);
	if(_enum != null) {
		if(_enum.indexOf(value) == -1) { return false; }
	}
	if(region != null) {
		region = JSON.parse(region);
		for(r in region.rules) {
			if(r == rule) {
				region.rules[r] = value;
				return true;
			}
		}
	}
	
	return false;
}

function setRegionProperty(data, region_name, key, value) {
	var region = data.get('region_'+region_name);
	if(region != null) {
		region = JSON.parse(region);
		for(k in region) {
			if(k == key) { //Prevent adding new keys
				region[k] = value;
				return true;
			}
		}
	}
	
	return false;
}

//Set Region pos1 or pos2
function setRegionPos(data, region_name, posnum, x, y, z) {
	if(typeof(posnum) == typeof(undefined)) { var posnum = 1; }
	if(typeof(x) == typeof(undefined)) { var x = null; }
	if(typeof(y) == typeof(undefined)) { var y = null; }
	if(typeof(z) == typeof(undefined)) { var z = null; }
	var region = data.get('region_'+region_name);
	if(region != null) {
		region = JSON.parse(region);
		for(a in arguments) {
			if(a == 3) { region.pos['x'+posnum.toString()] = x; }
			if(a == 4) { region.pos['y'+posnum.toString()] = y; }
			if(a == 5) { region.pos['z'+posnum.toString()] = z; }
		}
		data.put('region_'+region_name, JSON.stringify(region));
		return true;
	}
	return false;
}

function isInRegion(pos, pos1, pos2) {
	var min_x = Math.min(pos1.x, pos2.x);
	var min_y = Math.min(pos1.y, pos2.y);
	var min_z = Math.min(pos1.z, pos2.z);
	var max_x = Math.max(pos1.x, pos2.x);
	var max_y = Math.max(pos1.y, pos2.y);
	var max_z = Math.max(pos1.z, pos2.z);
	
	var is = (pos.x >= min_x
		 && pos.y >= min_y
		 && pos.z >= min_z
		 && pos.x <= max_x
		 && pos.y <= max_y
		 && pos.z <= max_z
	);
	/*
	print('x1: '+min_x+' px: '+pos.x+' x2: '+max_x);
	print('y1: '+min_y+' py: '+pos.y+' y2: '+max_y);
	print('z1: '+min_z+' pz: '+pos.z+' z2: '+max_z);
	print('InREG'+is.toString());
	*/
	return is;
}

function updateRegion(e, data, region_name) {
	var region = getRegion(data, region_name);
	if(region != null) {
		var region_status = getRegionStatus(e, data, region);
		
		switch(region_status) {
			case 'LOCKDOWN_EXPIRED': {
				var pmails = getMails(data, region.owner);
				var isNotified = false;
				var timeDiff = getStringTime('2d');
				var mailTitle = "&6Region &9&o"+region.name+"&6 seized.";
				for(ppm in pmails) {
					var pm = pmails[ppm];
					if(pm.to == region.owner) {
						if(occurrences(pm.title, mailTitle) > 0) {
							isNotified = true;
						}
					}
				}
				if(!isNotified) {
					sendMail(data, null, region.owner, mailTitle, "Your lockdown time has expired for &9&o"+region.name+"&r and is not your property anymore.");
				}
				break;
			}
			case 'RENT_EXPIRED': {
				var pmails = getMails(data, region.owner);
				var isNotified = false;
				//var timeDiff = getStringTime('2d');
				var mailTitle = '&6Rent expired for region: &9&o'+region.name;
				for(ppm in pmails) {
					var pm = pmails[ppm];
					if(pm.to == region.owner) {
						if(occurrences(pm.title, mailTitle) > 0) {
							isNotified = true;
						}
					}
				}
				if(!isNotified) {
					sendMail(data, null, region.owner, mailTitle, "Your renting period for '&9&o"+region.name+"'&r has been expired.\nYou have a lockdown period of &o"+getTimeString(region.lockdownTime)+"&r.\nAfter that your region is for sale again.");
				}
				break;
			}
		}
	}
}

function getRegionStatus(e, data, region) {
	if(region.owner != null) {
		var now = new Date();
		if(now.hasPassed(region.rentCredit)) {
			//Rent expired
			if(now.hasPassed(region.rentCredit+region.lockdownTime)) {
				//Lockdown time expired
				return "LOCKDOWN_EXPIRED";
			} else {
				//Expired rent, but in lockdown time
				return "RENT_EXPIRED";
				
			}
		} else {
			//Renting not expired
			return "OWNED";
		}
	} else {
		if(region.forSale) {
			return "FOR_SALE";
		} else {
			return "NOT_OWNED";
		}
	}

	return false;
}

function getPlayerRegions(data, player) {
	var region_reg = /region_([\w])/g;
}

//=== REGION SCRIPTS ===//

var _REGIONS = []; //Regions where player is in
var _OLD = {
	x: null,
	y: null,
	z: null,
};









function getPlayerStats(w, player, showstats) {
	if(typeof(showstats) == typeof(undefined)) { var showstats = []; }
	var _sk = [];
	var pl = w.getAllPlayers();
	var haspl = false;
	for(p in pl) {
		if(pl[p].getName() == player.getName()) {
			haspl = true;
		}
	}
	if(!haspl) { return false; }
	
	if(typeof(showstats) == 'string') { showstats = [showstats]; }
	if(showstats.length == 0) {
		_sk = _SKILLS;
	} else if(showstats.length > 0) {
		for(i in showstats) {
			var _stat = showstats[i].toLowerCase().rangeUpper(0, 1);
			for(n in skill_names) {
				if( (skill_names[n].match(new RegExp(_stat, 'g')) || []).length > 0 ) {
					if(showstats.indexOf(_SKILLS[n]) == -1) {
						showstats.push(_SKILLS[n]);
						break;
					}
				}
			}
		}
	}
	var sk = getSkills(player, _sk);
	var sko = [];
	sko.push([
		['[=======] ', 'white', 0, 1],
		[player.getName()+'\'s Stats', 'red'],
		['[=======] ', 'white', 0, 1],
	]);
	for(skk in sk) {
		var lsk = sk[skk];
		sko.push(getRawSkillString(getSkillNameFromSkill(skk), lsk.level, lsk.xp));
	}
	
	return sko;
	
}






/*
Bridge between Reskillable-Compatskills mod and Custom NPCs
*/

var _SKILLS = [
	/*'compatskills.archery',
	'compatskills.trading',
	'compatskills.woodcutting',
	'compatskills.enchanting',*/
	'reskillable.attack',
	'reskillable.defense',
	'reskillable.farming',
	'reskillable.magic',
	'reskillable.mining',
	'reskillable.agility',
	'reskillable.building',
	'reskillable.gathering',
];

var _TRAITS = [
	//'compatskills.rename_tag',
	//'compatskills.more_deals',
];

//add xp objectives
var xp_stats = [];
var skill_names = [];
for(s in _SKILLS) {
	xp_stats[s] = _SKILLS[s].replace(/[\w]+\.([\w]+)/g, "$1_xp"); //Converts 'reskillable.mining' to 'mining_xp'
	skill_names[s] = _SKILLS[s].replace(/[\w]+\.([\w]+)/g, "$1").rangeUpper(0,1); //Converts 'reskillable.mining' to 'Mining'
}

function getXpStatFromSkill(skill_id) {
	return skill_id.replace(/[\w]+\.([\w]+)/g, "$1_xp");
}


function getSkillNameFromSkill(skill_id) {
	return skill_id.replace(/[\w]+\.([\w]+)/g, "$1").rangeUpper(0, 1);
}

function getRawSkillString(skillname, level, xp) {
	var skn = [];
	var pxp = xp;
	var mxp = getMaxXp(level);
	if(level < 99) {
		var pcol = 'red';
		var xpprog = Math.round(100/mxp*pxp);
		
		if(xpprog >= 75) {
			pcol = 'blue';
		} else if(xpprog >= 50) {
			pcol = 'green';
		} else if(xpprog >= 25) {
			pcol = 'gold';
		}
		
		skn.push([skillname, 'blue', 0, 1]);
		skn.push([' - Level: ', 'yellow', 0, 1]);
		skn.push([level.toString()+' ', 'red']);
		skn.push(['- XP: ', 'yellow', 0, 1]);
		skn.push([pxp.toString()+'/'+mxp.toString()+' ', pcol, 0, 0]);
		skn.push([' [', 'white']);
		
		var progdone = '';
		var progtodo = '';
		
		for(var j = 0; j < Math.round(20/100*xpprog); j++) {
			progdone += '|';
		}
		
		for(var j = 0; j < Math.round(20/100*(100-xpprog)); j++) {
			progtodo += '|';
		}
		
		skn.push([progdone, 'green']);
		skn.push([progtodo, 'red']);
		skn.push(['] ', 'white']);
		//skn.push(['- Progress: ', 'yellow', 0, 1]);
		skn.push([xpprog.toString()+'%', pcol, 0, 1]);
	} else {
		skn.push([skillname, 'blue', 0, 1]);
		skn.push([' - Max Level (Total XP: ', 'green', 0, 1]);
		skn.push([pxp.toString(), 'gold', 0, 1]);
		skn.push([')', 'green', 0, 1]);
	}
	return skn;
}

function hasTraits(player, traits) {
	
	if(typeof(traits) == 'string') { traits = [traits]; }
	var s = getSkills(player, null, traits);
	var t = 0;
	for(k in s) {
		var skill = s[k];
		for(u in skill.unlockables) {
			if(traits.indexOf(skill.unlockables[u]) > -1) {
				t++;
			}
		}
	}
	
	return t == traits.length;
}


function getMaxXp(lvl) {
	return 10+(Math.max(lvl-1, 0)*(2*Math.max(lvl, 1)));
}

function getSkillArray(player, skills, traits) {
	if(typeof(skills) == typeof(undefined)) { var skills = null; }
	if(typeof(traits) == typeof(undefined)) { var traits = null; }
	var s = getSkills(player, skills, traits);
	var a = [];
	for(n in s) { a.push(n); }
	return a;
}

function getSkills(player, skills, traits) {
	if(typeof(skills) == typeof(undefined)) { var skills = null; }
	if(typeof(traits) == typeof(undefined)) { var traits = null; }
	
	if(skills == null) {
		skills = _SKILLS;
	}
	if(traits == null) {
		traits = _TRAITS;
	}
	var pskills = {};
	var nbt = player.getNbt();
	var w = player.world;
	var sb = w.getScoreboard();
	var pp = nbt.getCompound('PlayerPersisted');
	var sk = pp.getCompound('SkillableData').getCompound('SkillLevels');
	for(k in skills) {
		var skill = sk.getCompound(skills[k]);
		var unlocks = [];
		var unl = skill.getCompound('unlockables');
		var sxp = 0;
		var sxp_obj = sb.getObjective(getXpStatFromSkill(skills[k]));
		if(sxp_obj != null) {
			var sxp_sc = sxp_obj.getScore(player.getName());
			if(sxp_sc != null) {
				sxp = sxp_sc.getValue();
			}
		}
		for(u in traits) {
			if(parseInt(unl.getByte(traits[u])) == 1) {
				unlocks.push(traits[u]);
			}
		}
		
		pskills[skills[k]] = {
			id: skills[k],
			level: skill.getInteger('level'),
			xp: sxp,
			skillPoints: skill.getInteger('skillPoints'),
			unlockables: unlocks
		};
		//print(skills[k]+': '+pskills[skills[k]].level.toString());
	}
	
	return pskills;
}


function init(e) {
	
	//Check for mail
	(function(e){
		var p = e.player;
		var w = p.world;
		var data = w.getStoreddata();
		
		var mails = getMail(data, p);
		if(mails.length > 0) {
			tellPlayer(p, strf("&7You have "+mails.length+" new mail(s).\n!mail read to see your mail."));
		} else {
			tellPlayer(p, strf("&7You don't have new mail."));
		}
	})(e);

	(function(e){
		var player = e.player;
		var timers = player.getTimers();
		var w = player.world;
		var data = w.getStoreddata();
		var pos = player.getPos();
		_OLD.x = pos.getX();
		_OLD.y = pos.getY();
		_OLD.z = pos.getZ();
		timers.forceStart(1, 20*45, true);
		//Register permissions to Alteria if non-existend
		//Build Everywhere, including every region
		registerCommandPerm(data, 'alteria.build');
		
		//Build in parts of world that is not a region
		registerCommandPerm(data, 'alteria.build.unclaimed');
		
		registerCommandPerm(data, 'regions');
		addPermMetaList(data, 'regions', 'buildable');
		addPermMetaListItem(data, 'regions', 'buildable', [
			'minecraft:crafting_table',
			'minecraft:furnace',
			'minecraft:chest',
		]);
		
	})(e);
	

	(function(e){
		var w = e.player.world;
		var sb = w.getScoreboard();
		var data = w.getStoreddata();

		for(i in xp_stats) { //Loop XP stat IDs
			var stat = xp_stats[i];
			//Does stat not exists?
			if(!sb.hasObjective(stat)) {
				//Register XP stat to scoreboard
				executeCommand(e.player, '/scoreboard objectives add '+stat+' dummy');
			}
			//Set player default value to stat
			var ostat = sb.getObjective(stat);
			if(ostat != null) {
				var score = ostat.getScore(e.player.getName());
				if(score == null) {//Register player to stat if not before
				score = ostat.createScore(e.player.getName());
				score.setValue(0);
			}
		}
	}
})(e);

	
	

}

function attack(e) {
	
}

function timer(e) {
	
	(function(e){
		var pl = e.player;
		var w = pl.world;
		var data = w.getStoreddata();
		
		switch(e.id) {
			case 1: {//Region update
				
				break;
			}
		}
	})(e);

}

function broken(e) {
	// if(e.block.getName() == 'customnpcs:npcscripted' && (e.player.getGamemode() == 1 ? !e.player.isSneaking(): true)) {
		// e.setCanceled(true);
	// }
	
	(function(e){
		var pl = e.player;
		var w = pl.world;
		var data = w.getStoreddata();
		var sb = w.getScoreboard();
		var permit = false;
		var bpos = e.block.getPos();
		var brpos = {'x':bpos.getX(),'y':bpos.getY(),'z':bpos.getZ()};
		var dkeys = data.getKeys();
		for(dk in dkeys) {
			var reg_id = dkeys[dk];
			
			if( (reg_id.match(/region_([\w\.]+)/g) || []).length > 0 ) {
				var reg_name = reg_id.replace(/region_([\w\.]+)/g, '$1');
				var reg = getRegion(data, reg_name);
				if(reg != null) {
					if(isValidRegion(reg)) {
						//tellPlayer(pl, strf('&cIn region: '+reg.name));
						var pos1 = {
							'x': reg.pos.x1,
							'y': reg.pos.y1,
							'z': reg.pos.z1,
						};
						var pos2 = {
							'x': reg.pos.x2,
							'y': reg.pos.y2,
							'z': reg.pos.z2,
						};
						
						if(isInRegion(brpos, pos1, pos2) && reg.dimension.toString() == w.getDimension().getId().toString()) {//Is block in region
							print('in region');
							if(reg.owner == pl.getName()) {
								if(hasPermission(pl, 'regions.'+reg.name+'.self.build', true, false, false)) {
									permit = true;
								} else {
									var sbperm = getPerm(data, 'regions');
									if(sbperm != null) {
									
										if(typeof(sbperm.metadata.buildable) != typeof(undefined)) {
											if(sbperm.metadata.buildable.items.indexOf(e.block.getName()) != -1) {
												permit = true;
											}
										}
									
									}
								}
							} else {
								print('Not owned, check permit:'+'regions.'+reg.name+'.build');
								if(hasPermission(pl, 'regions.'+reg.name+'.build', true, false, false)) {
									permit = true;
								}
							}
						}
					}
				}
			}
		}
		if(!hasPermission(e.player, 'alteria.build', false, true, false) && !permit) {
			tellPlayer(e.player, [
				['You aren\'t allowed to break here!', 'red']
			]);
			e.setCanceled(true);
		}
	})(e);

}

function build(e) {
	
}

function damaged(e) {
	
}

function died(e) {
	
}

function damagedEntity(e) {
	
}

function interact(e) {
	
	(function(e){
		if(e.type == 2) {//Interacts block?
			var pl = e.player;
			var w = pl.world;
			var data = w.getStoreddata();
			var sb = w.getScoreboard();
			var permit = false;
			var bpos = e.target.getPos();
			var pblock = getHandItem(pl);
			var brpos = {'x':bpos.getX(),'y':bpos.getY(),'z':bpos.getZ()};
			
			if(pblock != null) { //Has item in one of both hands?
				if(pblock.isBlock()) {
					var dkeys = data.getKeys();
					for(dk in dkeys) {//loop data for regions
						var reg_id = dkeys[dk];
						//Check every region
						if( (reg_id.match(/region_([\w\.]+)/g) || []).length > 0 ) {
							var reg_name = reg_id.replace(/region_([\w\.]+)/g, '$1');
							var reg = getRegion(data, reg_name);
							
							if(reg != null) {
								if(isValidRegion(reg)) {
									//tellPlayer(pl, strf('&cIn region: '+reg.name));
									var pos1 = {
										'x': reg.pos.x1,
										'y': reg.pos.y1,
										'z': reg.pos.z1,
									};
									var pos2 = {
										'x': reg.pos.x2,
										'y': reg.pos.y2,
										'z': reg.pos.z2,
									};
									
									//Check block placing
									if(isInRegion(brpos, pos1, pos2) && reg.dimension.toString() == w.getDimension().getId().toString()) {//Is block in region
										if(reg.owner == pl.getName()) {
											if(hasPermission(pl, 'regions.'+reg.name+'.self.build', true, false, false)) {
												permit = true;
											} else {
												var sbperm = getPerm(data, 'regions');
												if(sbperm != null) {
												
													if(typeof(sbperm.metadata.buildable) != typeof(undefined)) {
														if(sbperm.metadata.buildable.items.indexOf(pblock.getName()) != -1) {
															permit = true;
														}
													}
												
												}
											}
										} else {							
											if(hasPermission(pl, 'regions.'+reg.name+'.build', true, false, false)) {
												permit = true;
											}
										}
									}
								}
							}
						}
					}
					if(!hasPermission(e.player, 'alteria.build', false, true, false) && !permit) {
						tellPlayer(e.player, "");
						tellPlayer(e.player, [
							['You aren\'t allowed to build here!', 'red']
						]);
						e.setCanceled(true);
					}
				}
			}
		}
	})(e);

}

function kill(e) {
	
}

function tick(e) {
	
	(function(e){
		var pl = e.player;
		var w = pl.world;
		var data = w.getStoreddata();
		var dkeys = data.getKeys();
		var ppos = pl.getPos();
		var pos = {
			'x': ppos.getX(),
			'y': ppos.getY(),
			'z': ppos.getZ()
		};
		for(dk in dkeys) {
			var dkey = dkeys[dk];
			if( (dkey.match(/region_([\w\.]+)/g) || []).length > 0) {
				var region_id = dkey.replace(/region_([\w\.]+)/g, '$1');
				var region = getRegion(data, region_id);
				var in_region = false;
				if(region != null) {
					if(isValidRegion(region)) {
						var rpos = region.pos;
						var iir = isInRegion(pos, {'x':rpos.x1,'y':rpos.y1,'z':rpos.z1}, {'x':rpos.x2,'y':rpos.y2,'z':rpos.z2});
						if(iir && region.dimension == w.getDimension().getId()) {
							in_region = true;
						}
					}
				}
				if(in_region) {
					if(_REGIONS.indexOf(region_id) == -1) {
						_REGIONS.push(region_id);
						executeCommand(pl, '/title '+pl.getName()+' clear');
						if(region.enterText != '') {
							executeCommand(pl, '/title '+pl.getName()+' actionbar '+strf(region.enterText, true));
						}
					}
				} else {
					if(_REGIONS.indexOf(region_id) != -1) {
						if(region.leaveText != '') {
							executeCommand(pl, '/title '+pl.getName()+' actionbar '+strf(region.leaveText, true));
						}
						var NEW_REGIONS = [];
						for(rr in _REGIONS) {
							if(_REGIONS[rr] != region_id) {
								NEW_REGIONS.push(_REGIONS[rr]);
							}
						}
						_REGIONS = NEW_REGIONS;
					}
				}
				
			}
		}
		
	})(e);

	(function(e){
		var w = e.player.world;
		var sb = w.getScoreboard();
		var pskills = getSkills(e.player);
		for(i in xp_stats) {
			var stat = xp_stats[i];
			if(sb.hasObjective(stat)) {
				var o = sb.getObjective(stat);
				if(o.getScore(e.player.getName()) != null) {
					var sc = o.getScore(e.player.getName());
					var xp = sc.getValue();
					//Player levelup
					var skill_id = _SKILLS[i];
					var skill = pskills[skill_id];
					if(xp >= getMaxXp(skill.level)) {
						executeCommand(e.player, "/reskillable incrementskill "+e.player.getName()+" "+skill_id);
						xp -= getMaxXp(skill.level);
						executeCommand(e.player, "/scoreboard players set "+e.player.getName()+" "+stat+" "+xp.toString());
						executeCommand(e.player, "/tellraw "+e.player.getName()+" "+rawformat([
							['You just advanced to level '+(skill.level+1).toString()+' in '+skill_names[i]+'!', 'yellow']
						]));
					}
				}
			}
		}
	})(e);

}

function chat(e) {
	
	(function(e){
		if(e.message.substr(0, 1) == '!') {
			executeXCommand(e.player, e.message);
			
			e.setCanceled(true);
		}
	})(e);

}