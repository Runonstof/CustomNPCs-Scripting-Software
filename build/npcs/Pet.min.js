
var MCP = {
    "ItemStack_getItem": "func_77973_b",
    "Item_getEquipmentSlot": "func_185083_B_",
    "EntityLivingBase_travel": "func_191986_a",
    "Entity_onGround": "field_70122_E",
    "EntityLivingBase_setAIMoveSpeed": "func_70659_e",
    "EntityLivingBase_getAIMoveSpeed": "func_70689_ay",
    "EntityLiving_getMoveHelper": "func_70605_aq",
    "EntityMoveHelper_strafe": "func_188488_a",
};

function lengthdir_x(length, angle) {
	return length * Number(Math.cos(toRadians(angle))).toFixed(2) * -1;
}

function lengthdir_z(length, angle) {
	return length * Number(Math.sin(toRadians(angle))).toFixed(2);
}

function toRadians(angle) {
  return angle * (Math.PI / 180);
}

//Get angle between two points (2-dimensional)
function getPosAngle(x1, y1, x2, y2) {
	return Math.atan2(y2-y1, x2-x1) *(180/Math.PI);
}


function sign(num) {
	if(typeof(num) == typeof(undefined)) { num = 0; }
	if(num > 0) { return 1; }
	if(num < 0) { return -1; }
	return 0;
}

function roundDec(num, dec) {
	if(typeof(dec) == typeof(undefined)) { dec = 1; }
  	var mult = Math.pow(10, dec);

  	return Math.round(num*mult)/mult;
}

function fixAngle(angle) {
	return Number((Math.abs(angle) % 360) * sign(angle)).toFixed(2);
}

function posdir(pos, dir, pitch, len, flying) {
	if(typeof(dir) == typeof(undefined)) { dir = 0; }
	if(typeof(pitch) == typeof(undefined)) { pitch = 0; }
	if(typeof(len) == typeof(undefined)) { len = 1; }
	if(typeof(flying) == typeof(undefined)) { flying = false; }
	var x = pos.getX();
	var y = pos.getY();
	var z = pos.getZ();
	var xdir = getQuartRotation(dir);
	var zdir = getQuartRotation(dir-90);
	x += Math.round(len*(Math.abs(xdir)/90)*sign(xdir));
	z += Math.round(len*(Math.abs(zdir)/90)*sign(zdir));
	if(flying) {
		y += (len)*(Math.abs(pitch)/90)*-sign(pitch);
	}
	return {x:x,y:y,z:z};
}

function lengthpitch_y(pitch, length) {
	return Math.round(pitch/-90)*length;
}

function getQuartRotation(dir) {
	dir = getHalfRotation(dir);

	if(Math.abs(dir) > 90) {
		dir = (180-Math.abs(dir))*sign(dir);
	}

	return dir;
}

function getHalfRotation(angle) {
	angle = fixAngle(angle);
	if(angle <= 180) { return angle; } else { return -(180-(angle-180)); }
}

var API = Java.type('noppes.npcs.api.NpcAPI').Instance();
var INbt = Java.type('noppes.npcs.api.INbt');
var LogManager = Java.type('org.apache.logging.log4j.LogManager');
var Logger = LogManager.getLogger(typeof CONFIG_SERVER != typeof undefined ? CONFIG_SERVER.NAME : "");
var ForgeLoader = Java.type("net.minecraftforge.fml.common.Loader").instance();

var NbtTypes = {
    "Byte": 1,
    "Short": 2,
    "Integer": 3,
    "Long": 4,
    "Float": 5,
    "Double": 6,
    "ByteArray": 7,
    "String": 8,
    "List": 9,
    "Compound": 10,
    "IntegerArray": 11,
};

function getNbtType(num) {
    for(var n in NbtTypes) {
var nbtType = NbtTypes[n];
        if(nbtType === num) { return n; }
    }
    return null;
}

function getMCModList() {
    var modlist = [];
    var loadmods = Java.type("net.minecraftforge.fml.common.Loader").instance().getModList();

    for(var mid in loadmods) {
var lmod = loadmods[mid];
        modlist.push(lmod.getModId());
    }

    return modlist;
}

function hasMCMod(name) {
    return getMCModList().indexOf(name) > -1;
}

var _RAWCOLORS = {
	'0': 'black',
	'1': 'dark_blue',
	'2': 'dark_green',
	'3': 'dark_aqua',
	'4': 'dark_red',
	'5': 'dark_purple',
	'6': 'gold',
	'7': 'gray',
	'8': 'dark_gray',
	'9': 'blue',
	'a': 'green',
	'b': 'aqua',
	'c': 'red',
	'd': 'light_purple',
	'e': 'yellow',
	'f': 'white',
};

var _RAWEFFECTS = {
	'o': 'italic',
	'l': 'bold',
	'k': 'magic',
	'm': 'strike',
	'n': 'underline',
	'r': 'reset'
}

var _RAWCODES = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS));
function getColorId(name) {
	for(var i in _RAWCOLORS) {
		if(name == _RAWCOLORS[i]) {
			return i;
		}
	}
	for(var i in _RAWEFFECTS) {
var re = _RAWEFFECTS[i];
		if(name == re) {
			return i;
		}
	}
	return 'r';
}
function getColorName(id) {
	for(var i in _RAWCOLORS) {
var rc = _RAWCOLORS[i];
		if(id == i) {
			return rc;
		}
	}
	for(var i in _RAWEFFECTS) {
var re = _RAWEFFECTS[i];
		if(id == i) {
			return re;
		}
	}
	return 'white';
}

function ccs(str, af) {
	if(typeof(af) == typeof(undefined)) { af = null; }
	return colorCodeString(str, af);
}

function colorCodeString(str, allowed_formats) {
	if(typeof(allowed_formats) == typeof(undefined)) { allowed_formats = null; }
	if(allowed_formats == null) {
		allowed_formats = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS));
	}
	allowed_formats = removeFromArray(allowed_formats, ['x', 'y']);
	return str.replace(new RegExp("&(["+allowed_formats.join("")+"])", 'g'), '\u00A7$1').replace(/&\\/g, '&');
}

function escCcs(str, esc_formats) {
	if(typeof(esc_formats) == typeof(undefined)) { esc_formats = null; }
	if(esc_formats == null) {
		esc_formats = _RAWCODES;
	}

	return str.replace(new RegExp('&(['+esc_formats.join("")+'])', 'g'), '');
}

function parseEmotes(str, allwd) {
	if(typeof(allwd) == typeof(undefined)) { allwd = []; }
	str = str.replaceAll(objArray(CHAT_EMOTES), '');
	for(var ce in CHAT_EMOTES) {
var chatemote = CHAT_EMOTES[ce];
    	if(allwd.length == 0  || allwd.indexOf(ce) > -1) {
		    str = str.replaceAll(':'+ce+':', chatemote);
		    str = str.replaceAll(':/'+ce+'/:', ':'+ce+':');
    	}
	}
	return str;
}


function strf(str, toRaw, allowed) {
	if(typeof(toRaw) == typeof(undefined)) { toRaw = true; }
	if(typeof(allowed) == typeof(undefined)) { allowed = null; }
	return strrawformat(str, toRaw, allowed);
}
var CHAT_CMD_RGX = /{[\s]*(?:([\w]+)[\s]*\:[\s]*([\w\W\/]+?)|\*)(?:[\s]*\|[\s]*([\w]+)[\s]*\:[\s]*([\w\W\/]+?[\s]*))?}/;
var CHAT_CMD_RGX_G = /{[\s]*(?:([\w]+)[\s]*\:[\s]*([\w\W\/]+?)|\*)(?:[\s]*\|[\s]*([\w]+)[\s]*\:[\s]*([\w\W\/]+?[\s]*))?}/g;


function strrawformat(str, toRaw, allowed) {
	if(typeof(toRaw) == typeof(undefined)) { toRaw = false; }
	var rf = [];
	var txt = '';
	var ri = -1;
	var isCode = false;
	var txtColor = 'white';
	var isItalic = false;
	var isBold = false;
	var isStrike = false;
	var isUnderlined = false;
	var isObf = false;
	str = str+'&r ';

	for(var i = 0; i < str.length; i++) {
		var c = str.substr(i, 1);
		if(c == '&' || i == str.length-1) {
			//Check if new section has to be made
			if(txt.length > 0) {
				ri++;
				var cmds = [];

				rf.push([txt, txtColor, isItalic, isBold, isUnderlined, isStrike, isObf]);
				isItalic = false;
				isBold = false;
				isUnderlined = false;
				isStrike = false;
				isObf = false;
				txtColor = 'white';
				txt = '';
			}
			isCode = true;
			continue;
		} else {
			if(!isCode) {
				txt += c.toString();
			} else {
				//Check Colors
				if(typeof(_RAWCOLORS[c]) != typeof(undefined)) {
					txtColor = _RAWCOLORS[c];
				}
				//Check Markup
				switch(c.toString()) {
					case 'o': {
						isItalic = true;
						break;
					}
					case 'l': {
						isBold = true;
						break;
					}
					case 'n': {
						isUnderlined = true;
						break;
					}
					case 'm': {
						isStrike = true;
						break;
					}
					case 'k': {
						isObf = true;
						break;
					}
					case 'r': {
						isItalic = false;
						isBold = false;
						isUnderlined = false;
						isStrike = false;
						isObf = false;
						txtColor = 'white';
						break;
					}
				}
				isCode = false;
			}
		}
	}

	return (!toRaw ? rf : rawformat(rf, true));
}

function rawformat(str_pieces, fullraw, allowed) {
	if(typeof(fullraw) == typeof(undefined)) { fullraw = true; }
	if(typeof(allowed) == typeof(undefined)) { allowed = null; }
	if(allowed == null) {
		allowed = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS)).concat(['x', 'y']);

	}
	var txt = '';
	if(fullraw) { txt+='[""'; }

	for(var i in str_pieces) {
		var p = str_pieces[i];
		var ntext = p[0].replace(/\"/g, '\\"');
		var nm =  ntext.match(CHAT_CMD_RGX) || [];
		if(nm.length > 0) {
			p[7] = nm[1];
			p[8] = nm[2];
			p[9] = nm[3];
			p[10] = nm[4];
			ntext = ntext.replace(nm[0], '');
		}
		var pc = '{"text":"'+ntext+'"';
		if(p[1]) {
			if(allowed.indexOf(getColorId(p[1])) == -1) {
				p[1] = 'white';
			}

			pc+=',"color":"'+p[1].toString()+'"';

		}
		if(p[2]) {
			if(allowed.indexOf('o') > -1) {
				pc+=',"italic":true';
			}
		}
		if(p[3]) {
			if(allowed.indexOf('l') > -1) {
				pc+=',"bold":true';
			}
		}
		if(p[4]) {
			if(allowed.indexOf('n') > -1) {
				pc+=',"underlined":true';
			}
		}
		if(p[5]) {
			if(allowed.indexOf('m') > -1) {
				pc+=',"strikethrough":true';
			}
		}
		if(p[6]) {
			if(allowed.indexOf('k') > -1) {
				pc+=',"obfuscated":true';
			}
		}

		if(p[7] && p[8]) { pc+=',"clickEvent":{"action":"'+p[7]+'","value":"'+p[8]+'"}'; }
		if(p[9] && p[10]) { pc+=',"hoverEvent":{"action":"'+p[9]+'","value":"'+ccs((p[10]||"").replace(/\$/g, '\u00A7'),allowed)+'"}'; }
		pc += '}';


		txt+=( fullraw ? ',' : '' )+pc.toString();
	}

	if(fullraw) {
		txt += ']';
	}

	return txt;
}


//
function worldOut(str) {
    API.getIWorld(0).broadcast(strf(str));
}



//FLY SETTINGS
//Pitch is 90 when player looks fully down
var FLY_MIN_PITCH = 10; //(if on 20, then: when player pitch is above 20 or below -20 the npc will fly up/down)
var FLY_SPEED = 2;

//Without these settings, controlled npc flight is very, very quirky
	//I tested it all out, some I dont understand why, but tested with on/off and does make the difference
var aiUpdate = {
	//Set moving type to standing
	"MovingType": 0,
	//Set body rotation to manual
	"StandingType": 1,
	//Set stop on interact to false
	"StopOnInteract": false,
	//Set returns home to false
	"ReturnsHome": false,
};

//Function to set the settings for an npc so they can fly/can be controlled properly
function updateNpcSettings(npc) {
	var npcAi = npc.getAi();

	//For tick friendlyness, i hope, tick is hostile by itself
	var hasChanged = false;

	//If we are gonna set something (like standing type, returns home etc), we are gonna check if it is not already that, to make it tick-friendly
	//(why set something to 2 when its already 2)

	for(var a in aiUpdate) { //Loop all keys we wanna update
		var au = aiUpdate[a];
		if(npcAi["get"+a]() != au) { //if the key is not value we want
			npcAi["set"+a](au); //Set the value
			hasChanged = true;
		}
	}
	//tick-friendlyness
	if(hasChanged) {
		npc.updateClient();
		npc.reset();
	}

}

function npcSetNavType(npc, type) {
	var npcAi = npc.getAi();
	//Temp fix
	var types = [
		0,
		1,
		2,
	];
	var ti = types.indexOf(npcAi.getNavigationType());
	while(npcAi.getNavigationType() != type) {
		npcAi.setNavigationType(types[ti]);
		ti = (ti+1 == types.length ? 0 : ti+1);
	}

}

function init(e) {
	updateNpcSettings(e.npc);
}

function projectileImpact(e) {
	//e.projectile.world.explode(e.projectile.getX(), e.projectile.getY(), e.projectile.getZ(), 5, false, false);
}

function projectileTick(e) {
	//
	e.projectile.world.spawnParticle("flame", e.projectile.getX(), e.projectile.getY(), e.projectile.getZ(), 1, 1, 1, 0.5, 150);
}

function interact(e) {
	if(e.player.isSneaking()) { //let the dragon switch between flying/standing
		var npcAi = e.npc.getAi();

		npcSetNavType(e.npc, (e.npc.getAi().getNavigationType() == 1 ? 0 : 1));

	} else {//if not sneaking
		if(e.npc.getRiders().length == 0 && e.player.getMount() == null) {
			//If npc has no riders and player is not sitting on something
			e.npc.addRider(e.player);//set the player as rider
		} else {
			e.npc.say("OOF");
		}

	}
}

function tick(e) {
	updateNpcSettings(e.npc);
	var riders = e.npc.getRiders();
	var mce = e.npc.getMCEntity();
	//if(riders.length > 0 && mce.field_70145_X != true && e.npc.ai.getNavigationType() == 1) mce.field_70145_X = true;
	//if(riders.length == 0 && mce.field_70145_X != false) mce.field_70145_X = false;
	for(var r in riders) {
var rider = riders[r]; //Loop the riders on npc

		if(rider.getType() == 1) { //If the rider is an player
			//e.npc.setPitch(rider.getPitch());
			e.npc.setRotation(rider.getRotation()); //Set rotation for fly-direction
			var ms = rider.getMoveStrafing();
			var mf = Math.round(rider.getMoveForward()); //Will be 1 when pressed W and -1 when S is pressed (or other key, depends on ur controls config)
			var mv = rider.getPitch(); //-90 when player looks up, 90 when player looks down
			var rot = fixAngle(rider.getRotation());

			if(ms != 0) {
				if(ms < 0) {
					//Shoot projectile
					var shot = e.npc.shootItem(e.npc.getX()-lengthdir_x(3, rot+90), e.npc.getY(), e.npc.getZ()+lengthdir_z(3, rot+90), e.npc.world.createItem("minecraft:fire_charge", 0, 1), 100);
					shot.setHasGravity(false);
					shot.setAccuracy(100);
					shot.setHeading(rider.getRotation(), rider.getPitch());
					shot.enableEvents();
					e.npc.world.playSoundAt(e.npc.getPos(), "minecraft:item.firecharge.use", 1, 1);
				}
			}

			if(mf != 0) {
				//e.npc.navigateTo(e.npc.getX()+lengthdir_x(4, rot), e.npc.getY(), e.npc.getZ()+lengthdir_z(4, rot), 5);
				e.npc.setMotionX(-lengthdir_x(FLY_SPEED-(FLY_SPEED/90*Math.abs(mv)), fixAngle(rider.getRotation()+90))*sign(mf));
				e.npc.setMotionZ(lengthdir_z(FLY_SPEED-(FLY_SPEED/90*Math.abs(mv)), fixAngle(rider.getRotation()+90))*sign(mf));

				//worldOut(e.npc.getMotionX()+" -- "+e.npc.getMotionZ());
				//e.npc.setMoveForward(rider.getMoveForward());

				//e.npc.setMoveForward(rider.getMoveForward()); //Set moveForward of npc, the npc will moce in direction it looks
				if(e.npc.getAi().getNavigationType() == 1) {
					if(Math.abs(mv) > FLY_MIN_PITCH) {
						e.npc.setMotionY((((FLY_SPEED/2)/90*Math.abs(mv))*-sign(mv))*sign(mf));
					}
				}
			} else if(e.npc.getMoveForward() != 0) {
				e.npc.setMoveForward(0);
			}

			break;//exit for-loop
		}
	}
}
