
var MCP = {
    "ItemStack_getItem": "func_77973_b",
    "Item_getEquipmentSlot": "func_185083_B_",
    "EntityLivingBase_travel": "func_191986_a",
    "Entity_onGround": "field_70122_E",
    "EntityLivingBase_setAIMoveSpeed": "func_70659_e",
    "EntityLivingBase_getAIMoveSpeed": "func_70689_ay",
    "EntityLiving_getMoveHelper": "func_70605_aq",
    "EntityMoveHelper_strafe": "func_188488_a"
};

function lengthdir_x(length, angle) {
	var ang = fixAngle(Math.abs(angle)+90)-180;
	var sang = fixAngle(Math.abs(angle))-180;

	var qang = Math.abs((Math.abs(ang)-90));
	//print("qang:"+qang.toString());
	return -((qang/90)*length)*sign(sang);
}
function lengthdir_z(length, angle) {
	var ang = fixAngle(Math.abs(angle)+180)-180;
	var sang = fixAngle(Math.abs(angle)+90)-180;

	var qang = Math.abs((Math.abs(ang)-90));
	//print("qang:"+qang.toString());
	return -(((qang/90)*length)*sign(sang));
}


function sign(num) {
	if(typeof(num) == typeof(undefined)) { num = 0; }
	if(num > 0) { return 1; }
	if(num < 0) { return -1; }
	return 0;
}

function fixAngle(angle) {
	return angle % 359;
}

function posdir(pos, dir, pitch, len, flying) {
	if(typeof(dir) == typeof(undefined)) { dir = 0; }
	if(typeof(pitch) == typeof(undefined)) { pitch = 0; }
	if(typeof(len) == typeof(undefined)) { len = 1; }
	if(typeof(flying) == typeof(undefined)) { flying = false; }
	var x = pos.getX();
	var y = pos.getY();
	var z = pos.getZ();
	var xdir = getQuartRotation(dir);
	var zdir = getQuartRotation(dir-90);
	x += Math.round(len*(Math.abs(xdir)/90)*sign(xdir));
	z += Math.round(len*(Math.abs(zdir)/90)*sign(zdir));
	if(flying) {
		y += (len)*(Math.abs(pitch)/90)*-sign(pitch);
	}
	return {x:x,y:y,z:z};
}

function lengthpitch_y(pitch, length) {
	return Math.round(pitch/-90)*length;
}

function getQuartRotation(dir) {
	dir = getHalfRotation(dir);
	
	if(Math.abs(dir) > 90) {
		dir = (180-Math.abs(dir))*sign(dir);
	}

	return dir;
}

function getHalfRotation(angle) {
	angle = fixAngle(angle);
	if(angle <= 180) { return angle; } else { return -(180-(angle-180)); }
}




//FLY SETTINGS
//Pitch is 90 when player looks fully down
var FLY_MIN_PITCH = 20; //(if on 20, then: when player pitch is above 20 or below -20 the npc will fly up/down)

//Without these settings, controlled npc flight is very, very quirky
	//I tested it all out, some I dont understand why, but tested with on/off and does make the difference
var aiUpdate = {
	//Set moving type to standing
	"MovingType": 0,
	//Set body rotation to manual
	"StandingType": 1,
	//Set stop on interact to false
	"StopOnInteract": false,
	//Set returns home to false
	"ReturnsHome": false,
};

//Function to set the settings for an npc so they can fly/can be controlled properly
function updateNpcSettings(npc) {
	var npcAi = npc.getAi();

	//For tick friendlyness, i hope, tick is hostile by itself
	var hasChanged = false;

	//If we are gonna set something (like standing type, returns home etc), we are gonna check if it is not already that, to make it tick-friendly
	//(why set something to 2 when its already 2)

	for(var a in aiUpdate) { //Loop all keys we wanna update
		var au = aiUpdate[a];
		if(npcAi["get"+a]() != au) { //if the key is not value we want
			npcAi["set"+a](au); //Set the value
			hasChanged = true;
		}
	}

	var mcnpc = npc.getMCEntity();
	var movespd = 15;
	if(mcnpc[MCP.EntityLivingBase_getAIMoveSpeed]() != movespd) {
		mcnpc[MCP.EntityLivingBase_setAIMoveSpeed](movespd);
	}


	//tick-friendlyness
	if(hasChanged) {
		npc.updateClient();
		npc.reset();
	}

}

function npcSetNavType(npc, type) {
	var npcAi = npc.getAi();
	//Temp fix
	var types = [
		0,
		1,
		2,
	];
	var ti = types.indexOf(npcAi.getNavigationType());
	while(npcAi.getNavigationType() != type) {
		npcAi.setNavigationType(types[ti]);
		ti = (ti+1 == types.length ? 0 : ti+1);
	}

}

function init(e) {
	updateNpcSettings(e.npc);
}



function interact(e) {
	if(e.player.isSneaking()) { //let the dragon switch between flying/standing
		var npcAi = e.npc.getAi();

		npcSetNavType(e.npc, (e.npc.getAi().getNavigationType() == 1 ? 0 : 1));

	} else {//if not sneaking
		if(e.npc.getRiders().length == 0 && e.player.getMount() == null) {
			//If npc has no riders and player is not sitting on something
			e.npc.addRider(e.player);//set the player as rider
		}

	}
}

function tick(e) {
	updateNpcSettings(e.npc);
	var riders = e.npc.getRiders();
	for(var r in riders) { //Loop the riders on npc
var rider = riders[r];
		if(rider.getType() == 1) { //If the rider is an player
			e.npc.setPitch(rider.getPitch());
			e.npc.setRotation(rider.getRotation()); //Set rotation for fly-direction

			var mf = Math.round(rider.getMoveForward()); //Will be 1 when pressed W and -1 when S is pressed (or other key, depends on ur controls config)
			var mv = Math.round(rider.getPitch()); //-90 when player looks up, 90 when player looks down
			if(mf != 0) {
				e.npc.setMoveForward(rider.getMoveForward());

				//e.npc.setMoveForward(rider.getMoveForward()); //Set moveForward of npc, the npc will moce in direction it looks
				if(e.npc.getAi().getNavigationType() == 1) {
					if(Math.abs(mv) > FLY_MIN_PITCH) {
						e.npc.setMotionY(-sign(mv)/4);
					}
				}
			} else if(e.npc.getMoveForward() != 0) {
				e.npc.setMoveForward(0);
			}

			break;//exit for-loop
		}
	}
}
