


var newDayInit = false;

function array_filter(a, fn) {
	var aa = [];
	for(var i in a) {
		if(fn(a[i])) { aa.push(a[i]); }
	}

	return aa;
}

function array_dist(a) {
	var b = [];
	for(var c in a) {
		if(b.indexOf(a[c]) == -1) {
			b.push(a[c]);
		}
	}

	return b;
}

function array_remove(array, element) {
  var index = array.indexOf(element);
  if (index !== -1) {
    array.splice(index, 1);
  }
}

function removeFromArray(arr, vals) {
	if(typeof(vals) == 'string') { vals = [vals]; }
	var a = arr;
	for(var v in vals) {
var val = vals[v];
		array_remove(a, val);
	}
	return a;
}
function removeFromArrayByKey(arr, keys) {
	var narr = [];
	for(var k in keys) {
var key = keys[k];
		keys[k] = parseInt(key);
	}
	for(var i in arr) {
var ari = arr[i];
		if(keys.indexOf(i) > -1) {
			narr.push(ari);
		}
	}
	return narr;
}

function inArray(a, val) {
	for(var k in a) { if(a[k] === val) { return true; } }
	return false
}

function array_merge(a1, a2) {
	var bb = [];
	for(var k in a1) {
		bb[k] = a1[k];
	}
	for(var k in a2) {
		bb[k] = a2[k];
	}
	return bb;
}

function arrayTransform(arr, elfn) {
	var newa = [];
	for(var a in arr) {
var arri = arr[a];
		newa.push(elfn(arri, a, arr));
	}
	return newa;
}

function arrayTakeRange(arr, start, end) {
	if(typeof(end) == typeof(undefined)) { end = null; }
	if(end == null) { end = arr.length; }
	var a = [];
	var _end = Math.min(end, arr.length);
	var _start = Math.min(start, _end);
	for(var i = _start; i < Math.min(end, arr.length); i++) {
		if(typeof(arr[i]) != typeof(undefined)) {
			a.push(arr[i]);
		}
	}
	return a;
}

function arrayOccurs(string, subArray, allowOverlapping, caseSensitive) {
	if(typeof(allowOverlapping) == typeof(undefined)) { allowOverlapping = false; }
	if(typeof(caseSensitive) == typeof(undefined)) { caseSensitive = true; }
	var occ = 0;
	for(var i in subArray) {
var sel = subArray[i];
		occ += occurrences(string, sel, allowOverlapping, caseSensitive);
	}

	return occ;
}

function arrayFormat(array, format, sep) {
	var joined = "";
  	for(var i = 0; i < array.length; i++) {
    	joined += format.fill({
        	"VALUE": array[i]
        })+(i == array.length-1 ? "" : sep||" ");
    }
  	return joined;
}
//==Reallife date handler for hiring regions etc

Date.prototype.addTime = function(addTime) {
	this.setTime(this.getTime()+addTime);
};

Date.prototype.hasPassed = function(passDate) {
	return (this.getTime() >= passDate.getTime());
};

//Converts TimeString to number
function getStringTime(timeString) {
	//0y4mon3d 6h 8min3s 800ms
	var reg = /([\d]+)([a-zA-Z]+)/g;
	var _m = timeString.match(reg);
	var newTime = NaN;
	var _tk = Object.keys(msTable);

	for(var m in _m) {
		var fm = _m[m];
		var nm = fm.replace(reg, '$1').cInt();
		var om = fm.replace(reg, '$2');
		if(nm != null) {
			if(isNaN(newTime)) { newTime = 0; }
			if(_tk.indexOf(om) != -1) {
				newTime += nm * (msTable[_tk[_tk.indexOf(om)]]);
			} else { newTime += nm; }
		}
	}

	return newTime;
}
//Converts number to TimeString
function getTimeString(stringTime, excludes) {
	if(typeof(excludes) == typeof(undefined)) { excludes = []; }
	var newTime = parseInt(stringTime);
	var newStr = '';
	for(var ms in msTable) {
		if(excludes.indexOf(ms) == -1) {
			var msnum = 0;
			while(newTime >= msTable[ms]) {
				msnum++;
				newTime -= msTable[ms];
			}
			if(msnum > 0) {
				newStr += msnum.toString()+ms;
			}
		}
	}


	return newStr;
}
function getFnArgs(fn) {
	var fnrgx = /function[\s]+([\w]+)\(([\w,\s]+)\)/;
	var fnstr = fn.toString();
	var fnargs = [];
	var m = fnstr.match(fnrgx);
	if(m != null) {
		
      	m[2].split(',').forEach(function(a){
        	fnargs.push(a.trim());
        });
      	
      	return fnargs;
	}
	
	return fnargs;
}
//Convert object to array
function objArray(obj) {
	var a = [];
	for(var i in obj) {
var o = obj[i];
		a.push(o);
	}
	return a;
}

function clone(obj) {
    var copy;

    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}

//Get functions in the object
function getAllFuncs(obj) {
    var props = [];

    do {
        props = props.concat(Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props.sort().filter(function(e, i, arr) {
       if (e!=arr[i+1] && typeof obj[e] == 'function') return true;
    });
}

//Merge 2 objects
function objMerge(obj1, obj2, inheritNewProps){
	if(typeof(inheritNewProps) == typeof(undefined)) { inheritNewProps = true; }
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) {
        if(inheritNewProps || Object.keys(obj1).indexOf(attrname) > -1) {
            obj3[attrname] = obj2[attrname];
        }
    }
    return obj3;
}
String.prototype.allMatch = function(regx) {
	var m = this.match(regx);
	var rr = [];
	for(var mm in m) {
		var mt = m[mm];
		var rx = regx.exec(this);
		rr.push(rx);
	}

	return rr;
};


String.prototype.cmatch = function(regx) {
	return (this.match(regx) || []).length;
};

String.prototype.rangeUpper = function(min, max) {
	var str = '';
	for(var i = 0; i < this.length; i++) {
		var c = this.substring(i, i+1); //curchar
		if(i >= min && i < max) {
			c=c.toUpperCase();
		}
		str+=c.toString();
	}
	return str;
};
String.prototype.rangeLower = function(min, max) {
	var str = '';
	for(var i = 0; i < this.length; i++) {
		var c = this.substring(i, i+1); //curchar
		if(i >= min && i < max) {
			c=c.toLowerCase();
		}
		str+=c.toString();
	}
	return str;
};

String.prototype.pad = function(character, len) {
	var n = this.toString();
	for(var i = n.length; i < len; i++) {
		n += character.toString();
	}
	return n;
};

String.prototype.fill = function(payload) {
	var str = this.toString();
	for(var p in payload) {
var payl = payload[p];
		str = str.split("{"+p+"}").join(payl);
	}
	return str;
}

String.prototype.padMiddle = function(character, len) {

	var n = this.toString();
	var sc = Math.floor((len-n.length)/2);
	var ns = '';
	for(var i = 0; i < sc; i++) {
		ns += character.toString();
	}
	ns+=n;
	for(var i = 0; i < sc; i++) {
		ns += character.toString();
	}
	return ns;
};

String.prototype.cInt = function() {
	return (isNaN(parseInt(this)) ? null : parseInt(this));
};


String.prototype.append = function(ch, amount) {
	var new_str = this.toString();
  	for(var i = 0; i < amount; i++) {
    	if(i >= new_str.length) {
        	new_str += ch.toString();
        }
    }

  return new_str;
};

String.prototype.prepend = function(ch, amount) {
	var new_str = this.toString();
  	for(var i = 0; i < amount; i++) {
    	if(i >= new_str.length) {
        	new_str = ch.toString()+new_str;
        }
    }

  return new_str;
};

String.prototype.replaceAll = function(search, replacement) {
    var target = this.toString();
    if(typeof(search) == 'string') { search = [search]; }
		for(var s in search) {
var sr = search[s];
			target = target.split(sr).join(replacement);
		}
		return target;
};

function occurrences(string, subString, allowOverlapping, caseSensitive) {
	if(typeof(allowOverlapping) == typeof(undefined)) { allowOverlapping = false; }
	if(typeof(caseSensitive) == typeof(undefined)) { caseSensitive = true; }
    string = string.toString()
    subString = subString.toString()

	if(!caseSensitive) {
		string = string.toLowerCase();
		subString = subString.toLowerCase();
	}

    if (subString.length <= 0) return (string.length + 1);

    var n = 0,
        pos = 0,
        step = allowOverlapping ? 1 : subString.length;

    while (true) {
        pos = string.indexOf(subString, pos);
        if (pos >= 0) {
            ++n;
            pos += step;
        } else break;
    }
    return n;
}



//Java import
var API = Java.type('noppes.npcs.api.NpcAPI').Instance();
var INbt = Java.type('noppes.npcs.api.INbt');
var LogManager = Java.type('org.apache.logging.log4j.LogManager');
var Logger = LogManager.getLogger(typeof CONFIG_SERVER != typeof undefined ? CONFIG_SERVER.NAME : "");
var ForgeLoader = Java.type("net.minecraftforge.fml.common.Loader").instance();

var NbtTypes = {
    "Byte": 1,
    "Short": 2,
    "Integer": 3,
    "Long": 4,
    "Float": 5,
    "Double": 6,
    "ByteArray": 7,
    "String": 8,
    "List": 9,
    "Compound": 10,
    "IntegerArray": 11,
};

function getNbtType(num) {
    for(var n in NbtTypes) {
var nbtType = NbtTypes[n];
        if(nbtType === num) { return n; }
    }
    return null;
}

function getMCModList() {
    var modlist = [];
    var loadmods = Java.type("net.minecraftforge.fml.common.Loader").instance().getModList();

    for(var mid in loadmods) {
var lmod = loadmods[mid];
        modlist.push(lmod.getModId());
    }

    return modlist;
}

function hasMCMod(name) {
    return getMCModList().indexOf(name) > -1;
}


//UUIDLeast-Most
function UUIDLM() { return rrandom_range(1, 99999); }

function getDropChance(npcnbt, slot) {
	var dropC = npcnbt.getList('DropChance', 10);
	var dropChance = parseInt(dropC[slot].getInteger('Integer'));

	return dropChance;
}




function getHandItem(player) {
	return player.getMainhandItem() || player.getOffhandItem();
}

//Get unique ID
function uniqid() {
	var id = '';
	for(var i = 0; i <= 3; i++) {
		id+=Math.random().toString(36).substr(2, 9);
	}
	return id;
}

//Vanilla item attributes
var _ITEMATTR = [
	'generic.attackDamage',
	'generic.followRange',
	'generic.maxHealth',
	'generic.followRange',
	'generic.knockbackResistance',
	'generic.movementSpeed',
	'generic.armor',
	'generic.armorToughness',
	'generic.attackSpeed',
	'generic.luck',
	'generic.attackKnockback',
	'generic.flyingSpeed',
	'generic.luck'
];

//Escape JSON symbols
function escapeNbtJson(json, trim_ends) {
	if(typeof(trim_ends) == typeof(undefined)) { trim_ends = true; }
	json = json.replace(/(?:\\n|\\)/g, '');
	json = json.replace(/(\d) ([fbds]+)/g, "$1$2");
	json = json.replace(/\\("|')/g, "$1");
	if(trim_ends) {
		json = json.slice(1, json.length - 1);
	}

	return json;
}

function getDayTime(time) {
	while(time > 24000) { time -= 24000; }
	return time;
}

function isArray(obj) {
	if(typeof(obj) === 'object') {
      for(var k in obj) {
          if(isNaN(k)) {
			  return false;
		  }
      }
      return true;
    } else { return false }
}

function isObject(obj) {
	return ( typeof(obj) === 'object' && !isArray(obj) );
}



function init(e){
	
}

function load(e) {
	
}

function interact(event){
	var pl = event.player, inv = pl.getInventory(), hand = pl.getMainhandItem(), trader = event.npc.getRole(), profit = 0, mult = 1, curCountF = 0, curCountS = 0;

	if(!pl.isSneaking()) return;
	event.setCanceled(true);
	if(hand && hand.getName()=="backpacks16840:backpack") {
		var bp = getBackpackInv(pl, hand);
		//IItemStack[] backpack items
		var bpItems = getIItemStackArray(bp.items);
	}
	//Trader's inventory cycle
	for(var i=0;i<18;i++){
		if(bp){
			//same as below but for backpack items array
			curCountF = getArrItemCount(bpItems, trader.getCurrency1(i));
			curCountS = getArrItemCount(bpItems, trader.getCurrency2(i));
		} else {
			curCountF = pl.inventoryItemCount(trader.getCurrency1(i));
			curCountS = pl.inventoryItemCount(trader.getCurrency2(i));
		}
		if((!trader.getCurrency1(i).isEmpty() && curCountF >= trader.getCurrency1(i).getStackSize()) || (!trader.getCurrency2(i).isEmpty() && curCountS >= trader.getCurrency2(i).getStackSize())){
			//Multipiler. Operations per trade actually
			//+ Silly way to fix bug
			if(!trader.getCurrency1(i).isEmpty()){
				mult = curCountF / trader.getCurrency1(i).getStackSize();
				if(!(parseInt(mult) === mult)) {
					curCountF = curCountF - (curCountF % trader.getCurrency1(i).getStackSize());
					mult = Math.floor(mult);
				}
			} else {
				mult = curCountS / trader.getCurrency2(i).getStackSize();
				if(!(parseInt(mult) === mult)) {
					curCountS = curCountS - (curCountS % trader.getCurrency2(i).getStackSize());
					mult = Math.floor(mult);
				}
			}

			//Adding to profit variable how much does it cost
			profit += getCoinAmount(trader.getSold(i).getLore()[0].replace(/\s+/g, '')) * trader.getSold(i).getStackSize() * mult;
			if(!trader.getCurrency1(i).isEmpty())
				if(bp) {
					//same as below but for backpack items array
					bp.items = getMCItemStackArray(arrayItemRemove(bpItems, trader.getCurrency1(i), curCountF));
					bp.saveInventory();
				} else
					pl.removeItem(trader.getCurrency1(i), curCountF);
			if(!trader.getCurrency2(i).isEmpty())
				if(bp) {
					//same as below but for backpack items array
					bp.items = getMCItemStackArray(arrayItemRemove(bpItems, trader.getCurrency2(i), curCountS));
					bp.saveInventory();
				} else
					pl.removeItem(trader.getCurrency2(i), curCountS);
		}
	}
	//You know that part. Stolen from your code XD Will give player his profit
	var pm = genMoney(pl.getWorld(), profit);
	for(var p in pm) {
		var pii = pm[p];
		pl.giveItem(pii);
	}
}

function timer(e){
	
}

function tick(e){
	
	(function(e){
		var w = e.npc.world;
		if(getDayTime(w.getTime()) < 100 && newDayInit == false) {
			if(typeof(newDay) != typeof(undefined)) {
				newDay(e);
			}
			newDayInit = true;
		}
		if(getDayTime(w.getTime()) >= 100 && newDayInit == true) {
			newDayInit = false;
		}
	})(e);

}

function collide(e){
	
}

function damaged(e){
	
}

function died(e){
	
}

function kill(e){
	
}

function meleeAttack(e){
	
}

function rangedAttack(e){
	
}

function target(e){
	
}

function targetLost(e){
	
}

function role(e){
	
}
